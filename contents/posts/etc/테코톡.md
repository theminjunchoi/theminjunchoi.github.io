---
title:
date: 2025-02-11 09:44:21
updated: 2025-10-29 11:13:12
publish:
tags:
series:
---
### P.1
안녕하세요.
분산환경에서 게임 구현을 위한 Redis 사용기를 주제로 발표를 진행할 엠제이라고 합니다.
이제 다들 테코톡이 끝나서 그런지 편안한 얼굴로 앉아계시네요.
미미만 안좋은 것 같아요. 그럼 시작하겠습니다.
### P.2
들어가기 앞서, 오늘 발표할 내용은 저희 커피빵이라는 서비스 개발 과정 중 일부입니다.
그래서 다른 도메인에서는 오늘 내용이 유효하지 않을 수도 있다는 점을 미리 밝힙니다.
### P.3
우선 몇가지, 여러분들이 알고 넘어가야할 내용이 있는데요. 
첫 번째는, 저희 서비스 완전 초창기 모습입니다. 너무 단순하고 이쁘죠?
저희 서비스는 한 번씩 써보셨으면 알텐데, 게임을 번복하거나, 전날 게임 기록을 불러온다는지 하는 기능이 없기 때문에 데이터 베이스가 필요가 없었어요. 그래서 단순히 메모리에서만 구현을 했었습니다.

두 번째는, 스프링에서 웹소켓 통신을 구현한 방법이에요. 
루키의 테코톡을 보고 오시면 더 자세히 이해를 할 수 있는데요, 
오늘 이 발표에서 필요한 내용만 요약하면 다음과 같아요.
처음에 클라이언트와 서버가 handshake를 하면 tcp 연결이 수립이 돼요.
### P.4
그럼 스프링은 내부적으로 클라이언트의 sessionId를 관리를 하게 되는데, 이 덕분에 추후 서버가 클라이언트들에게 다같이 broadcast를 해줘야할 때 관리를 하고 있는 클라이언트들의 sessionId를 보고 메시지를 전송을 할 수 있습니다.

본격적인 내용을 이해하기 위한 모든 준비가 된 것 같아요. 
### P.5
자 이제 더 많은 사용자들이 이 서비스에 몰리면 어떻게 될까요?
실제로 부하 테스트를 해보면 생각보다 이 인스턴스는 웹소캣 메시지를 수신하고, 송신하는데 병목 현상이 생긴다는 걸 확인할 수 있었는데요. 1차적으로 이를 해결할 수 있는 방법은 역시
### P.6
스케일아웃하는 것이었습니다. 웹소켓 메시지를 송수신할 수 있는 인스턴스를 늘리면 병목을 해결할 수 있는데요. 
그럼 다음과 같은 문제가 생깁니다. 
이제부터 잘 따라오셔야해요.
### P.7
저희 서비스에 카드게임이 있는데 다들 아시죠?
예를 들어 유저1이 카드를 하나 선택했다고 해봅시다. 그리고 이때 유저1이 인스턴스A에게 연결되어 있었다면, 카드가 선택됐다는 메시지도 역시 인스턴스A에게로 갈텐데요.
### P.8
기존 방식이라면 로컬 메모리에서 관리되던 게임 데이터가 업데이트가 되고, 인스턴스A가 관리하던 유저들에게 브로드캐스트를 해줄거에요. 하지만 이러면 문제가 생기죠.

같은 방에 플레이하던 유저가 인스턴스B에게 연결이 되어있었다면,
인스턴스B는 오래된 게임데이터를 갖고 있게 되고, 인스턴스B에 연결되어있던 유저들도 업데이트를 못 받게 돼요.
### P.9
이처럼 게임 상태와 유저 정보를 어디에 저장하고 어떻게 동기화할거냐! 가 이 상황의 핵심 문제입니다.
### P.10
우선 여러 인스턴스가 함께 정보를 공유하는 방법에 대해 생각해봤는데요.
게임 상태를 어디에 저장할 수 있을까 고민을 해봤는데 처음에 이렇게 3개가 떠올랐어요. 
늘 사용하던 DB, 글로벌 캐시, 혹은 로컬캐시도 가능하지 않을까 생각이 들었습니다.

그럼 이렇게 저장을 하면, 값을 업데이트 한 인스턴스말고도 다른 인스턴스도 이 변화했다는 점을 알아야하잖아요? 이를 위해 Redis를 사용할 수 있겠다는 생각이 들었습니다. 다들 여기저기서 Redis에 대해 한 번쯤은 들어보셨을텐데, 이를 간략하게 설명하면,
### P.11
Remote Dictionary Server라고 해서, 인메모리 데이터 저장소를 뜻합니다.
우리가 자주 사용하는 Mysql처럼 디스크에서 데이터들을 관리하는 게 아니라 메모리에서 관리를 하기 때문에 디스크 IO가 없어서 비교적 빠르다는 특징이 있어요.
### P.12
이제 이런 애를 어디에 쓸 수 있냐!하면 다음과 같은 곳들에서 사용할 수 있는데요.
여러 인스턴스에서 사용하는 데이터를 중앙에서 관리, 혹은 캐싱을 한다거나 메시지를 전달해주는 브로커 역할을 한다거나, 뿌려지는 이벤트를 기반으로 집계 및 분석을 할 수가 있어요.
오늘 이 곳에서는 중앙 세션 저장소와 메시지 브로커로서 Redis를 사용해보겠습니다.
### P.13
우선 방금 보여드렸던 3가지 옵션 중에 첫 번째, 우리가 늘 사용하던 DB에 게임 상태를 저장해볼게요.
### P.14
똑같이 유저1이 카드를 선택하면 메시지가 기존 연결되어있던 인스턴스A에게 흘러갈텐데, 이때 A는 DB에서 게임을 조회하고, 객체로서 비즈니스 로직을 처리하고 다시 저장을 하게 될거에요.
그리고 Redis가 없다면, 그대로 인스턴스A는 본인이 관리하고 있는 유저들에게만 브로드캐스트를 할텐데, 그럼 여전히 인스턴스B에서는 DB가 바뀌었는지 알 수가 없어서 기존과 같은 문제가 생기고 있습니다.
### P.15
이제 이 상황에서 Redis가 어떻게 사용되는지 보여드릴게요.
### P.16
여전히 게임 상태는 DB에서 관리를 하고 있고요. 이제는 Redis가 생겼습니다.
### P.17
똑같이 카드 선택 메시지를 인스턴스A가 받아서, DB로부터 값을 조회하고, 변경해서 저장까지 하게 되는데, 
### P.18
이때 바로 본인이 관리를 하던 유저들에게 브로드캐스트를 하는게 아니라 Redis에 메시지를 보내요.
이 메시지는 DB가 변경됐다는 정보를 담고 있는데요.
### P.19
이때 Redis는 그 메시지를 그대로, 본인과 연결되어있는 모든 인스턴스들에게 전달을 해요. 브로킹을 하고 있는거죠. 그러면 모든 인스턴스는 이 메시지, 즉 이벤트를 수신을 해서
### P.20
바뀐 DB를 다시 조회하러갑니다.
### P.21
그리고 변경된 값을 찾아서 각 인스턴스가 관리를 하는 유저들에게 브로드캐스트를 해줄 수 있어요.
앞서 설명한 과정대로 전파를 하면 같은 방에 참여를 하고 있는 모든 유저들은 거의 동시에 메시지를 수신할 수 있습니다.
### P.22
이제 다시 장단을 따져볼까요?
우선 늘 사용하던 죽마고우 같은 DB, 대부분 편리하게 JPA를 사용하게 될텐데 이렇게 하면 러닝커브 없이 이 문제를 풀 수 있는게 장점이에요. 하지만 어쩔 수 없이 생기는 네트워크 비용마다 DB에서는 디스크를 조회해서 값을 찾아오기 때문에 느릴 수가 있어요. 그럼 2번째 방법을 봐볼까요
### P.23
이 방법은 기존에 늘 사용하던 Mysql같은 RDBMS없이 Redis로만 구현한 방법인데요. 
보시는 것처럼 각 인스턴스는 본인의 로컬 메모리에서 게임상태를 관리하지 않고 전부 Redis라는 글로벌 캐시에서 관리를 하고 있어요. 똑같이 흐름을 따라가볼게요.
### P.24
유저1이 카드 선택을 해서 메시지가 인스턴스A에게 꽂히게 됩니다. 이때 인스턴스A는 Redis에 저장된 값을 불러와서 비즈니스 로직을 처리하고 다시 Redis에 저장을 하게돼요.
### P.25
그리고 Redis에게 메시지를 쏩니다. 
### P.26
그럼 기존1에서와 마찬가지로, Redis는 받은 메시지를 그대로 브로킹해서 본인과 연결되어있는 인스턴스들에게 송신을 하고 
### P.27 
그 메시지를 받은 인스턴스들은 Redis에서 변경된 값을 찾아와서 
### P.28
거의 동시에 본인들이 관리하던 유저들에게 브로드 캐스트를 해줘요.
### P.29
이것도 장단점을 따져볼까요?
2번 방법에서는 Redis를 중앙 세션 저장소로 쓰고, 메시지 브로커로도 사용해봤는데, 1번의 방식보다 빠른 읽기/쓰기가 가능합니다. 하지만 구현과정에서는 저장할 때 객체를 풀어헤쳐서 Redis에 저장하고, 조회할 땐 String이나 json 형태로 저장된 값을 그대로 읽어서 하나하나 객체로 변환해줘야하는 객체 직렬화/역직렬화가 필요했고, 비즈니스 로직 전개과정에서도 직렬과/역직렬화가 너무 자주 일어나서 확실히 오래걸리는 걸 체감할 수 있었어요. 이 문제는 도메인 객체가 복잡하고 커질수록 심해졌습니다. 
또 Redis는 내부적으로 단일 쓰레드로만 작업을 하고 있는데, 외부에서 Redis에게 요청을 많이 보내면 보낼 수록 이 Redis의 CPU 사용률이 올라갈 수 있어요.
그리고 또 역시 당연하게도 로컬 메모리에서 작업하는 것보단 느리죠.
### P.30
이제 마지막으로 로컬캐시에서 게임 상태를 관리하는 방법에 대해 알아볼게요.
이 그림처럼 현재 게임 상테는 각 인스턴스에서 관리를 해주고 있는데 어떻게 서로 다른 인스턴스에서 게임 상태를 동등하게 유지하는지 확인해보면 좋을 것 같아요.
### P.31
똑같이 카드 선택 메시지가 날라오고요.
### P.32
이때 인스턴스A는 본인 로컬 캐시에서 값을 확인만 하고, 변경없이 바로 Redis에 이벤트를 발송합니다.
하지만 이때 기존과 좀 차이가 있는데요,
예를 들어, 유저1이 5번위치에 있는 카드를 선택했으면, 이때 인스턴스A는 이벤트에 쏠 때 페이로드로 누가? 에 유저1, 뭐를? 에 5번위치 카드를 넣어서 이벤트를 쏘는거에요.
### P.33
그럼 모든 인스턴스가 이 이벤트를 수신해서,
### P.34
거의 동시에 본인 로컬에서 관리하는 게임 상태를 변경을 하고
### P.35
유저들에게 브로드캐스트를 해줄 수 있습니다.
### P.36 
하지만 여전히 장단은 있어요. 이 방법은 1,2번 방법보단 읽기 성능이 압도적으로 빠르고, Redis에 값을 저장하거나 조회하는 로직이 없어요. 그러다보니 요청을 덜 하게 되고 Redis가 건강해집니다.
대신 모든 인스턴스가 중복된 게임상태를 가지게 되는 단점이 있어요.
### P.37
이제 다시 처음으로 돌아와서,
게임 상태와 유저 정보를 어떻게 저장하고, 어떻게 동기화 할 것인가에 대해 3가지 옵션이 있었는데요,
첫 번째 방법은 지웠어요. 아무래도 실시간 게임이라 레이턴시가 중요했고, Redis를 안써봐서 좀 더 적극적으로 활용해보고 싶었습니다.
그럼 2가지 방법이 남았는데요, 이 둘을 다시 비교를 해볼게요.
### P.38
앞서 설명한 장단점은 다음과 같아요.
저는 무엇보다 중앙 집중형 병목이 생길 수 있다는 게 눈에 들어왔었는데요, 현재는 돈이 없어 클러스터링 없이 하나만 사용하고 있는 Redis가 단일장애지점이 되면 안되겠다라는 생각을 했었고, 어떤 방법이 조금이라도 안전할지 확인하고자 부하테스트를 해봤습니다.
### P.39
부하테스트 내용은 다음과 같아요.
1000명이 10초동안 50ms 간격으로 웹소켓 메시지를 보내봤습니다.
그러면 초당 20000번의 요청이 Redis로 가게 되는데, 스펙 상 t4g micro로 띄운 Redis가 최소 2만건에서 4만건의 메시지를 버틸 수가 있다고 해서 이와 같이 테스트를 진행했습니다
### P.40
각각 5번씩 동일한 부하를 주면서 테스트를 진행했는데 결과는 다음과 같아요.
평균 cpu 사용률이 16%에서 7.5%로 기존대비 절반정도 감소한 모습을 볼 수 있어요.
또 이 자료화면에는 없지만, 기존 2번 방법에서는 매 요청마다 직렬과/역직렬화 과정을 거쳐야해서 유저가 메시지를 받는데까지 시간이 길었는데, 3번 방식으로 바꾸면서 이 지연이 줄어들었다는 것을 확인할 수 있었습니다.
### P.41
그래서 저희는 현재 3번구조를 적용하고 있는데요, 여전히 한계점은 존재하고 있어요.
### P.42
각 인스턴스가 Redis에게 메시지를 쏠 때는 Fire And Forget 방식을 사용합니다.
그래서 운이 안좋으면 메시지가 유실이 되는 경우도 있습니다.

또한 카드게임을 보면 알 수 있다시피 동시성 문제가 생길 수가 있는데요,
만약 서로 다른 유저가 동일한 카드를 거의 동시에 선택을 했을 때 각각의 요청이 서로 다른 인스턴스에게 흘러가서 각 인스턴스는 아무도 선택안할 줄 알고 비즈니스 로직을 처리할 수 있어요.

이 부분도 고민할 수 있는게 많은데, 더 궁금하신분은 개인적으로 찾아보거나 끝나고 저와 더 이야기를 나누면 좋을 것 같습니다.