---
title: 지연의 원인을 찾아라
date: 2025-09-28 09:44:21
updated: 2025-10-15 09:57:54
publish:
tags:
series:
---


![[스크린샷 2025-09-28 오후 2.45.24.png]]![[스크린샷 2025-09-28 오후 2.45.33.png]]
## 0. 문제 원인 가설 세우기
P95가 15배 증가했는데, CPU, Memory 사용량이 정상 범위, 그럼 DB 관련 문제이지 않을까?
- DB 커넥션 풀 고갈
- 테이블 락 or 행 락 경합 (업데이트와 조회가 동시에)
- N+1 문제 (커넥션 오래 점유)
- 복잡한 조회 쿼리 (인덱스 없음)

## 1. 현재 상황에서 문제를 어떻게 해결할 수 있을까?
### 1-1. 커넥션 풀 상태 진단
```bash
# 현재 커넥션 풀 상태
curl localhost:8080/actuator/metrics/hikaricp.connections.active
curl localhost:8080/actuator/metrics/hikaricp.connections.idle  
curl localhost:8080/actuator/metrics/hikaricp.connections.pending

# 커넥션 획득 대기 시간
curl localhost:8080/actuator/metrics/hikaricp.connections.acquire
```
### 1-2. DB 락 상황 확인
MySQL이 자체적으로 관리하는 메타데이터 저장소 infromation_schema가 있음
```sql
SELECT 
    r.trx_id waiting_trx_id,           -- 대기 중인 트랜잭션 ID
    r.trx_mysql_thread_id waiting_thread,  -- 대기 중인 스레드 ID
    SUBSTRING(r.trx_query, 1, 100) waiting_query,  -- 대기 중인 쿼리
    b.trx_id blocking_trx_id,          -- 블로킹하는 트랜잭션 ID  
    b.trx_mysql_thread_id blocking_thread,  -- 블로킹하는 스레드 ID
    SUBSTRING(b.trx_query, 1, 100) blocking_query,  -- 블로킹하는 쿼리
    w.blocking_lock_id,
    w.requesting_lock_id
FROM information_schema.innodb_lock_waits w    -- 락 대기 정보
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```
예시 결과:
```
waiting_trx_id | waiting_query              | blocking_trx_id | blocking_query
421036         | SELECT * FROM sales WHERE  | 421035          | UPDATE sales SET status=
421037         | SELECT * FROM sales WHERE  | 421035          | UPDATE sales SET status=
421038         | SELECT * FROM sales WHERE  | 421035          | UPDATE sales SET status=
```
- 트랜잭션 421035가 `UPDATE sales SET status=...` 실행 중
- 트랜잭션 421036, 421037, 421038이 모두 대기
- **1명이 3명을 막고 있는 상황**
### 1-3. 쿼리 성능 분석
슬로우 쿼리 확인:
```sql
-- 최근 1시간 슬로우 쿼리
SELECT start_time, query_time, lock_time, rows_sent, rows_examined,
       SUBSTRING(sql_text, 1, 200) as sql_preview
FROM mysql.slow_log 
WHERE start_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)
ORDER BY query_time DESC
LIMIT 10;
```
실시간 프로세스 확인:
```sql
SELECT id, user, host, db, command, time, state,
       SUBSTRING(info, 1, 100) as query_preview
FROM information_schema.processlist 
WHERE command != 'Sleep' AND time > 2
ORDER BY time DESC;
```

## 2. 시스템 상태와 지표를 종합해볼 때, 추정되는 문제 원인은?
### 도메인 분석: 쇼핑몰 판매자 대시보드
#### 판매자 대시보드
- 실시간 판매량, 매출액
- 상품별 판매 현황
- 주문 처리 상태
- 리뷰/평점 통계
- 정산 관련 데이터
#### 조회 많은 시간
- 오전 9~11시: 판매자들 출근해서 전날 매출 확인
- 저녁 6~8시: 하루 마감 전 최종 확인
- 특정 이벤트 시: 타임세일 등
### 유력 원인: 대용량 집계 쿼리의 실시간 계산
```bash
판매자 100명이 동시에 대시보드 조회
↓
각자 n개씩 복잡한 집계 쿼리 실행  
↓
총 n * 100개의 무거운 쿼리가 동시 실행
↓
DB 리소스 경합 → 모든 쿼리 느려짐
↓
P95 15배 증가
```
- 오늘 매출 집계, 상품별 판매량 Top 10, 미처리 주문 수 등 실시간 데이터를 조회하는데, 이 과정에서 복잡한 Join이 생김. 
- 인덱스가 없으면 풀 스캔을 해야함
- 복잡한 쿼리를 요구하는 대시보드 조회 요청이 많아지면 커넥션 풀까지 고갈
- 근데 timeout이라면 로그가 남아야하는데 안남음.
- 커넥션 반환이 늦어지면서 톰캣이 새로운 요청을 못받아서 그 밖에서 500에러가 터짐

## 3. 서비스 안정성을 위해 즉각적으로 취할 수 있는 대응 방법은?
### 3-1. 커넥션 풀 확장 & CPU 스펙 향상
maxinum-pool-size 증가
connection-timeout 증가
validation-timesout 증가
### 3-2. 쿼리 최적화
핵심 인덱스 생성
## 4. 문제 해결 및 재발 방지를 위한 근본적인 개선책은?
### 4-1. Primary-Replica 구조로 DB부하 분산
### 4-2. 로컬 or Redis 캐시 도입
인기 상품이 있을 경우, 구매가 자주일어나서 매번 캐시를 초기화하는 건 성능 저하 유발
성능을 위해 5분, 10분 or 하루단위로 새벽에 캐싱 도입
## 4-3. 집계 테이블 도입: 미리 계산해두기
### 근본적인 문제는 실시간 계산
판매자가 대시보드를 조회할 때마다 아래와 같은 쿼리가 항목별로 발생함
```sql
-- 오늘 매출 계산 (실시간)
SELECT 
    COUNT(*) as order_count,
    SUM(oi.quantity * oi.price) as total_amount
FROM orders o
JOIN order_items oi ON o.id = oi.order_id  
JOIN products p ON oi.product_id = p.id
WHERE p.seller_id = 12345 
  AND o.created_at >= '2024-01-15 00:00:00'
  AND o.created_at < '2024-01-16 00:00:00'
  AND o.status IN ('PAID', 'SHIPPED', 'DELIVERED');

-- 데이터량: orders 100만건 × order_items 300만건 × products 50만건
-- 실행시간: 5-8초
-- 결과: order_count=157, total_amount=2,340,000
```
- **같은 계산을 반복**: 판매자가 새로고침할 때마다 똑같은 집계 연산
- **데이터량은 계속 증가**: 주문 쌓일수록 계산 시간 늘어남
- **동시 요청시 부하 급증**: 100명이 동시 조회하면 100번 계산

### 집계 테이블 모습
```sql
-- 집계 테이블 (미리 계산된 결과 저장)
CREATE TABLE seller_daily_stats (
    seller_id BIGINT,
    stat_date DATE,
    order_count INT,           -- 미리 계산된 주문 수
    total_amount DECIMAL(15,2), -- 미리 계산된 총액
    avg_amount DECIMAL(10,2),   -- 미리 계산된 평균
    updated_at TIMESTAMP,
    PRIMARY KEY (seller_id, stat_date)
);

-- 데이터 예시
INSERT INTO seller_daily_stats VALUES 
(12345, '2024-01-15', 157, 2340000.00, 14904.46, NOW());
```
- 동시 요청 부하 해결
- 커넥션 점유 시간 단축
### 집계 테이블 업데이트 전략
- 실시간 업데이트
- 배치 업데이트

---
