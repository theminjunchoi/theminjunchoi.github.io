---
title: 신규 자동이체 시스템을 설계해보자
date: 2025-02-11 09:44:21
updated: 2025-10-15 09:58:03
publish:
tags:
series:
---

![[스크린샷 2025-10-01 오후 8.40.41.png]]
![[스크린샷 2025-10-01 오후 8.40.51.png]]
## 0. 뭐가 중요할까
- **멱등성 보장 안 되면 중복 이체 발생** 
- **분산 환경에서 동시 실행 방지 안 하면 같은 이체 2번 탐**
- **부분 실패 시 데이터 정합성 깨짐**
- **배치 처리 중 서버 죽으면 어디까지 했는지 모름**
- **은행 API 장애 시 전체 멈춤**

돈은 장애 대응이 핵심이다.
## 1. DB 테이블 구조
기본적인 테이블은 구축되어있다는 가정 하에, 장애 대응용 컬럼들 추가
### 1-1. 자동이체 설정 테이블 추가 사항
- version(낙관적락용): 동시 수정 방지
- last_executed_at(마지막 실행 시간): 중복 실행 체크용
- *retry_count*(재시도 횟수): 계속 실패하는 애들 파악용
- execution_lock_until(실행 락 만료 시간): 분산 락 대신 DB 락으로 쓸 수 있음
	- Redis 같은 외부 분산 락 시스템 쓰면 좋겠지만 Redis도 장애지점이 될 수 있거나 
	- 인프라 제약이 있거나
	- 외부 의존성 없이 DB 만으로 해결하고 싶을 때

### 1-2. 이체 이력 테이블 추가사항
- *[idempotency_key](https://docs.tosspayments.com/reference/using-api/authorization) (*멱등성 키): 중복 실행 방지의 핵심
    - `{transfer_id}:{실행예정일}:{nonce}` 형태로 생성
    - 이게 없으면 같은 이체 2번 타는 거 못 막음
- external_transaction_id (외부 거래 ID): 은행 API 응답 ID
    - 은행에서 실제로 처리했는지 조회할 때 필요
- processing_started_at, processing_ended_at: 처리 시간 추적용

### 1-3. 배치 실행 상태 테이블
- 배치 돌릴 때마다 레코드 하나 박음
- 배치 ID, 시작 시각, 종료 시각, 처리 건수, 실패 건수, 상태(RUNNING/COMPLETED/FAILED)
- 서버 죽었을 때 재시작 지점 찾는 용도
- 배치가 RUNNING 상태로 2시간 넘게 있으면? → 장애 알람

## 2. 자동이체 실행 흐름
분산 환경 동시 실행 방지가 핵심
서버 2대 이상이거나 재부팅하면 여러번 배치를 돌 수 있음, 그럼 같은 이체 여러번 실행됨

### 해결책 1
- 분산락: Redis, DB (SELECT ... FOR UPDATE SKIP LOCKED)

### 해결책 2
멱등성 키 생성: 같은 이체를 여러번 실행해도 한 번만 처리될 수 있게 해야함
- 이체 실행 전에 idempotency_key 생성
- 이력 테이블에 이미 같은 키 있는지 체크
- 있으면? → 이미 처리했다는 거니까 스킵
- 없으면? → 처리 진행

왜 중요하냐
- 서버 죽었다가 재시작할 때
- 네트워크 타임아웃으로 재시도할 때
- 이거 없으면 같은 금액 2번 빠져나감 → 고객 빡침 → 소송

### 상황 1: 부분 실패
- 한 청크(1000건) 처리 중 500번째에서 DB 락 타임아웃
- 그럼 앞에 499건은? → 커밋됐으면 처리됨, 안 됐으면 롤백
- 재시도할 때 499건 스킵하고 500번부터 해야 하는데 어떻게?

해결:
- 각 이체마다 별도 트랜잭션 (기본)
- 근데 **실패한 건 이력에 FAILED 찍고 다음 거 계속 처리**
- 전체 배치는 멈추지 않음
- retry_count 증가시키고 다음 실행일은 그대로 (재시도용)

### 상황 2: 타임 아웃과 서킷 브레이커
- 은행 API 응답 느려짐 (10초씩 걸림)
- 20만 건 처리하면? → 2시간 넘게 걸림 → 실패

해결:
- 각 은행 API 호출에 타임아웃 3초 설정
- 3초 안에 응답 없으면 FAILED 처리하고 다음 거 진행
- 연속으로 실패 많이 나면 서킷 브레이커 열어서 일시 중단
- 특정 은행 API만 장애면 해당 은행 이체만 스킵하고 나머지 처리

## 3. 이력 저장 방식
### 이력은 절대 삭제/수정 불가능 (Immutable)
- 이력 테이블은 INSERT ONLY
- UPDATE/DELETE 권한 아예 안 줌
- 법적 분쟁 생기면 이력이 증거
- 수정 가능하면 "회사가 조작했다" 이런 얘기 나옴

### 감사 로그는 별도 저장소에
- 설정 변경 이력은 메인 DB 말고 별도 로그 저장소(ELK, S3)에도 백업
- 누가, 언제, 어떤 IP에서, 뭘 바꿨는지 다 남김
- DB 날아가도 로그는 남아있어야 함

### 조회 성능 고려
- 이력 테이블은 무조건 커짐 (20만 건 × 365일 = 7천만 건/년)
- 파티셔닝 필수: 월별로 테이블 분리
- 1년 지난 데이터는 콜드 스토리지로 이관

## 4. 성능 제약 대응 전략
- 하루 = 86,400초
- 초당 20건 × 86,400초 = 1,728,000건 (이론적 최대치)
- 보수적으로 20만건, 중요한 건 성능 제약이 있다~

### 4-1. 우선순위 큐 도입
20만 건을 동등하게 처리하면 안 됨.
우선순위:
- P0 (최우선): 월급, 공과금 같은 중요 이체
- P1 (일반): 일반 자동이체
- P2 (저우선): 소액 이체

실패 시 재시도 횟수도 우선순위별로 다르게.

### 4-2. 점진적 롤아웃 
처음부터 20만 건 전부 돌리면 장애 시 임팩트 큼.
방법:
- 처음 10분: 1만 건만 처리 → 모니터링
- 이상 없으면: 5만 건 처리
- 최종: 전체 처리

실패율 5% 넘으면 자동 중단하고 알람.
### 4-3. 백프레셔(Backpressure) 처리
DB나 은행 API가 버티기 힘들면:
- 처리 속도 자동으로 줄임
- DB CPU 80% 넘으면 스레드 수 줄임
- 은행 API 에러율 올라가면 요청 간격 늘림

### 4-4. 데드레터 큐 (DLQ)
계속 실패하는 이체:
- 5번 재시도해도 실패하면 DLQ로 보냄
- 별도로 수동 처리하거나 고객센터 통보
- 메인 배치 흐름은 막지 않음

### 4-5. 장애 복구 시나리오
서버 죽었을 때:
1. 배치 상태 테이블에서 RUNNING 상태 찾음
2. 마지막 처리 시각 확인
3. 그 이후부터 재처리 (멱등성 키로 중복 방지)