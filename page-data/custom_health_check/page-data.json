{"componentChunkName":"component---src-templates-post-jsx","path":"/custom_health_check/","result":{"data":{"site":{"siteMetadata":{"title":"minjun.blog"}},"markdownRemark":{"id":"9ee459e1-d77e-53e2-83d1-cb928b7cc908","excerpt":"ZZOL 서비스에 커스텀 HealthIndicator와 자가복구(Self-Recovery) 로직을 추가하고, Health Group을 분리했다. Spring Boot의 기본 헬스체크가 어디까지 커버하고, 어디서부터 커스텀이 필요한지, 장애 감지 후 Docker 재시작 전에 애플리케이션 내부에서 먼저 복구를 시도해야 하는 이유, 그리고 DOWN과 OUT_O…","html":"<p>ZZOL 서비스에 커스텀 HealthIndicator와 자가복구(Self-Recovery) 로직을 추가하고, Health Group을 분리했다. Spring Boot의 기본 헬스체크가 어디까지 커버하고, 어디서부터 커스텀이 필요한지, 장애 감지 후 Docker 재시작 전에 애플리케이션 내부에서 먼저 복구를 시도해야 하는 이유, 그리고 DOWN과 OUT_OF_SERVICE를 왜 구분해야 하는지에 대한 판단 과정을 기록한다.</p>\n<h2>기본 헬스체크가 못 잡는 것</h2>\n<p>Spring Boot Actuator는 <code class=\"language-text\">/actuator/health</code>를 통해 서버 상태를 제공한다. Spring Boot가 자동으로 등록하는 HealthIndicator는 DataSource(DB 연결), Redis(PING 명령), DiskSpace(디스크 여유 공간) 등이 있다. ZZOL에서는 <code class=\"language-text\">show-details: always</code>로 상세 정보를 노출하고 있었고, Docker HEALTHCHECK가 이 엔드포인트를 30초마다 호출해서 컨테이너 상태를 판단하고 있었다.</p>\n<p>문제는 이것만으로는 <strong>ZZOL 도메인에서 의미 있는 장애를 감지할 수 없다</strong>는 것이었다.</p>\n<p>두 가지 시나리오가 기본 헬스체크를 통과하면서도 서비스에 문제를 일으킨다.</p>\n<p>첫째, <strong>서버가 Graceful Shutdown 중일 때.</strong> ZZOL은 배포 시 활성 WebSocket 세션이 모두 종료될 때까지 최대 5분간 대기한다. 이 5분 동안 서버는 살아있고, DB도 연결돼 있고, Redis도 응답한다. 기본 헬스체크는 UP을 반환한다. 하지만 이 서버에 새로운 트래픽을 보내면 안 된다. 기존 연결을 드레이닝하는 중이기 때문이다. 로드밸런서가 이 상태를 감지하지 못하면 종료 중인 서버에 새 플레이어가 접속하게 된다.</p>\n<p>둘째, <strong>Redis Stream의 ListenerContainer가 멈췄을 때.</strong> ZZOL은 방 생성, 방 참여, 미니게임, 레이싱 게임 등 5개 Redis Stream을 통해 이벤트를 비동기로 처리한다. <code class=\"language-text\">StreamMessageListenerContainer</code>가 예외로 인해 멈추면 이벤트 소비가 중단된다. 하지만 Redis 자체는 살아있으므로 기본 Redis HealthIndicator(PING)는 UP을 반환한다. DB도 정상이다. 그러나 이벤트 소비가 멈춘 서버는 실질적으로 절반의 기능이 죽은 상태다.</p>\n<h2>첫 번째 판단: 뭘 HealthIndicator에 넣을 것인가</h2>\n<p>처음에는 \"서비스에 문제가 될 수 있는 모든 것\"을 HealthIndicator에 넣으려고 했다. WebSocket 세션 수가 갑자기 0으로 떨어지면 DOWN, DB 커넥션 풀 사용률이 90%를 넘으면 DOWN, 이런 식이었다.</p>\n<p>하지만 한 가지 중요한 제약을 간과하고 있었다. <strong>Docker HEALTHCHECK에서 DOWN이 반환되면 컨테이너가 재시작된다.</strong> HealthIndicator는 \"이 상태가 비정상인가\"를 판단하는 게 아니라, **\"이 서버를 재시작하면 문제가 해결되는가\"**를 판단해야 한다.</p>\n<p>WebSocket 세션 수가 0인 건 서버를 재시작한다고 해결되는 문제가 아니다. 클라이언트가 접속하지 않은 것뿐이다. DB 커넥션 풀 사용률이 높은 것도 재시작으로 순간적으로 해소되지만, 근본 원인(슬로우 쿼리 등)이 해결되지 않으면 재시작 후 다시 올라간다. 이런 것들은 HealthIndicator가 아니라 **알림(Alerting)**으로 가야 한다.</p>\n<p>이 기준을 적용하면 HealthIndicator에 넣어야 하는 항목이 명확해진다.</p>\n<table>\n<thead>\n<tr>\n<th>상태</th>\n<th>재시작으로 복구 가능?</th>\n<th>HealthIndicator에 넣는가?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Redis Stream Container 중단</td>\n<td>ㅇㅇ. 재시작 시 container 재생성</td>\n<td>넣음</td>\n</tr>\n<tr>\n<td>Graceful Shutdown 진행 중</td>\n<td>재시작이 아니라 트래픽 차단이 필요</td>\n<td>넣음 (단, DOWN이 아닌 OUT_OF_SERVICE)</td>\n</tr>\n<tr>\n<td>WebSocket 세션 수 급감</td>\n<td>재시작으로 해결 안 됨</td>\n<td>안 넣음. 알림으로 처리</td>\n</tr>\n<tr>\n<td>DB 커넥션 풀 고갈</td>\n<td>일시적 해소만 가능</td>\n<td>안 넣음. 알림으로 처리</td>\n</tr>\n</tbody>\n</table>\n<h2>두 번째 판단: DOWN과 OUT_OF_SERVICE는 왜 다른가</h2>\n<p>Redis Stream Container가 멈추면 DOWN을 반환한다. Graceful Shutdown 중에는 OUT_OF_SERVICE를 반환한다. 둘 다 \"이 서버에 트래픽을 보내면 안 된다\"는 건 같은데, 왜 구분해야 하는가.</p>\n<p><strong>DOWN은 \"장애\"를 의미한다.</strong> Docker HEALTHCHECK에서 DOWN을 연속으로 받으면(<code class=\"language-text\">retries</code> 횟수만큼) 컨테이너를 재시작한다. Redis Stream Container가 멈춘 건 장애이고, 재시작으로 복구 가능하므로 DOWN이 맞다.</p>\n<p><strong>OUT_OF_SERVICE는 \"의도적인 서비스 중단\"을 의미한다.</strong> Graceful Shutdown은 배포를 위한 의도적인 종료 과정이다. 이 상태에서 컨테이너를 재시작하면 세션 드레이닝이 중단되고, 게임 중인 플레이어의 WebSocket 연결이 강제로 끊긴다. Graceful Shutdown을 구현한 의미가 사라진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Redis Stream Container stopped → DOWN → Docker restarts → Container recovered ✓\nGraceful Shutdown in progress → OUT_OF_SERVICE → Docker does NOT restart → Session draining continues ✓</code></pre></div>\n<p>처음에는 Graceful Shutdown에도 DOWN을 썼다가 이 문제를 발견했다. Graceful Shutdown이 시작되면 Docker가 \"장애\"로 판단하고 컨테이너를 재시작하려는데, 서버는 종료 중이므로 재시작과 종료가 충돌한다. OUT_OF_SERVICE로 바꾸면 Docker HEALTHCHECK는 이 상태를 unhealthy로 판단하지 않으면서, 로드밸런서는 이 인스턴스를 트래픽 분배 대상에서 제외할 수 있다.</p>\n<p>단, 이 동작은 Docker HEALTHCHECK 설정에 따라 다르다. Docker의 기본 HEALTHCHECK는 \"healthy 또는 unhealthy\"만 구분하고, HTTP 상태 코드를 직접 해석하지 않는다. <code class=\"language-text\">wget --spider</code>가 200이 아닌 503(OUT_OF_SERVICE의 기본 HTTP 상태)을 받으면 exit 1을 반환하므로, Docker 입장에서는 unhealthy로 처리될 수 있다. 이 부분은 로드밸런서(ALB 등)의 Health Check 설정에서 200만 healthy로 인식하도록 구성해야 한다.</p>\n<h2>세 번째 판단: 재시작이 정말 첫 번째 선택지인가</h2>\n<p>초기 설계에서는 Redis Stream Container가 멈추면 즉시 DOWN을 반환해서 Docker가 컨테이너를 재시작하도록 했다. 코드 리뷰에서 중요한 지적이 들어왔다.</p>\n<p><strong>\"단일 인스턴스 구조에서 컨테이너 재시작은 곧 100% 다운타임이다. ListenerContainer가 예외로 멈췄다면, 서버 전체를 죽이는 대신 해당 Container 빈만 다시 시작하는 Fallback 로직을 먼저 구현해야 하지 않나?\"</strong></p>\n<p>맞는 지적이었다. Container 하나 멈춘 건데 서버 전체를 재시작하는 건 과한 대응이다. 외부 인프라(Docker)에 의한 강제 재시작은 항상 최후의 보루(Last Resort)여야 한다.</p>\n<p>이 원칙을 적용해서 복구 흐름을 3단계로 재설계했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Container stopped\n       |\n       v\n[1] Recovery: container.start() 시도 (30초 주기)\n       |\n    성공? ──→ 정상 복귀. HealthIndicator는 UP.\n       |\n       no\n       |\n       v\n[2] Recovery: 재시도 (최대 2회)\n       |\n    성공? ──→ 정상 복귀\n       |\n       no\n       |\n       v\n[3] HealthIndicator: DOWN 반환 → Docker 재시작 (Last Resort)</code></pre></div>\n<p>여기서 중요한 설계 결정이 하나 있었다. <strong>HealthIndicator 안에서 복구 로직을 실행하면 안 된다.</strong> HealthIndicator는 \"상태를 보고하는 역할\"이지 \"상태를 고치는 역할\"이 아니다. Docker가 30초마다 헬스체크를 호출하는데, 매번 부수효과(side effect)가 발생하면 책임이 섞인다.</p>\n<p>그래서 두 컴포넌트를 분리했다.</p>\n<p><code class=\"language-text\">RedisStreamContainerRecovery</code>는 30초 주기의 스케줄 태스크로, 모든 container 상태를 감시하고 멈춘 container에 <code class=\"language-text\">start()</code>를 호출한다. 2회 연속 실패하면 \"복구 불가\"로 판정한다.</p>\n<p><code class=\"language-text\">RedisStreamHealthIndicator</code>는 Recovery의 결과만 읽어서 보고한다. \"복구 불가\" 판정이 난 스트림이 있으면 DOWN을 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Recovery: 상태 감시 + 복구 시도 (쓰기)</span>\n<span class=\"token annotation punctuation\">@Scheduled</span><span class=\"token punctuation\">(</span>fixedDelay <span class=\"token operator\">=</span> <span class=\"token number\">30_000</span><span class=\"token punctuation\">,</span> initialDelay <span class=\"token operator\">=</span> <span class=\"token number\">60_000</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">checkAndRecover</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> streamKey <span class=\"token operator\">:</span> <span class=\"token constant\">STREAM_KEYS</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">StreamMessageListenerContainer</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> container <span class=\"token operator\">=</span> <span class=\"token function\">getContainer</span><span class=\"token punctuation\">(</span>streamKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">isRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            recoveryFailureCounts<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>streamKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            failedRecoveryStreams<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>streamKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 멈춘 container → start() 시도</span>\n        container<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>container<span class=\"token punctuation\">.</span><span class=\"token function\">isRunning</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> failCount <span class=\"token operator\">=</span> recoveryFailureCounts<span class=\"token punctuation\">.</span><span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>streamKey<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Integer</span><span class=\"token operator\">::</span><span class=\"token function\">sum</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failCount <span class=\"token operator\">>=</span> <span class=\"token constant\">MAX_RECOVERY_ATTEMPTS</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                failedRecoveryStreams<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>streamKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 복구 포기</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// HealthIndicator: Recovery 결과만 읽기 (읽기 전용)</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Health</span> <span class=\"token function\">health</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>containerRecovery<span class=\"token punctuation\">.</span><span class=\"token function\">hasUnrecoverableStreams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token class-name\">Health</span><span class=\"token punctuation\">.</span><span class=\"token function\">down</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">withDetail</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unrecoverable\"</span><span class=\"token punctuation\">,</span> containerRecovery<span class=\"token punctuation\">.</span><span class=\"token function\">getFailedRecoveryStreams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">withDetail</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"action\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Internal recovery failed. Docker restart required.\"</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Health</span><span class=\"token punctuation\">.</span><span class=\"token function\">up</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">withDetails</span><span class=\"token punctuation\">(</span>details<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Recovery가 복구를 시도하는 동안에는 container가 STOPPED여도 HealthIndicator는 UP을 반환한다. 아직 내부에서 복구 중이니까 Docker가 개입할 단계가 아니다. 2회 연속 실패해서 \"복구 불가\"가 확정돼야 비로소 DOWN을 반환하고, Docker 재시작이 last resort로 트리거된다.</p>\n<h3>자주 오해하는 부분: Redis가 문제면 Redis를 재시작해야 하는 거 아닌가?</h3>\n<p>장애 시뮬레이션을 하면서 자주 받은 질문이다. \"Redis가 문제의 원인인데 왜 앱 컨테이너를 재시작하는 거냐. Redis 컨테이너를 재시작해야 하는 거 아니냐.\"</p>\n<p>처음에는 나도 같은 생각이었다. Redis가 죽으면 Redis를 살려야 한다고. 하지만 시뮬레이션을 해보니 문제의 구조가 달랐다.</p>\n<p>Redis가 잠깐 죽었다가 살아나면, Lettuce(Redis 클라이언트)가 커넥션을 자동으로 복구한다. 여기까지는 문제가 없다. 문제는 <strong>Redis Stream의 <code class=\"language-text\">StreamMessageListenerContainer</code>가 한 번 STOPPED 상태에 빠지면 Lettuce 커넥션이 복구돼도 자동으로 살아나지 않는다</strong>는 것이다. Lettuce는 Redis 커넥션을 관리하는 클라이언트이고, <code class=\"language-text\">StreamMessageListenerContainer</code>는 그 커넥션 위에서 이벤트를 구독하는 Spring 빈이다. 커넥션 복구와 빈의 생명주기는 별개의 문제다.</p>\n<p>그래서 Recovery가 하는 일은 Redis를 살리는 게 아니라, <strong>이미 Redis는 살아있는데 STOPPED 상태로 남아있는 Spring 빈(<code class=\"language-text\">StreamMessageListenerContainer</code>)의 <code class=\"language-text\">start()</code>를 호출하는 것</strong>이다. Docker 재시작도 마찬가지다. Redis 컨테이너를 재시작하는 게 아니라, 앱 컨테이너를 재시작해서 모든 Spring 빈을 초기 상태로 재생성하는 것이다.</p>\n<p>그렇다면 Redis 자체가 문제인 경우는? Redis가 완전히 죽어있거나, 메모리 부족으로 swap이 발생하거나, AOF rewrite가 과도하게 오래 걸리는 경우는 앱을 재시작해도 해결되지 않는다. 이런 상황은 사람이 원인을 파악해서 직접 조치해야 한다. 이 영역은 HealthIndicator가 아니라 Alert Rules가 담당한다. HealthIndicator는 \"앱 내부에서 자동으로 복구 가능한 문제\"를, Alert Rules는 \"사람이 개입해야 하는 문제\"를 각각 담당하는 구조다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Redis 장애 발생\n    |\n    +-- 앱 내부 문제 (Container STOPPED)\n    |     -> Recovery가 container.start()\n    |     -> 실패 시 Docker가 앱 재시작\n    |\n    +-- Redis 자체 문제 (프로세스 죽음, OOM 등)\n          -> Alert Rules가 사람에게 알림\n          -> 사람이 원인 파악 후 조치</code></pre></div>\n<h2>네 번째 판단: Health Group을 왜 분리하는가</h2>\n<p>Spring Boot Actuator는 Health Group 기능을 제공한다. 하나의 <code class=\"language-text\">/actuator/health</code> 아래에 여러 그룹을 만들 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">management</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">endpoint</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">health</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">group</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">liveness</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">include</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"ping\"</span>\n        <span class=\"token key atrule\">readiness</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">include</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"db,redis,gracefulShutdown,redisStream\"</span></code></pre></div>\n<p><strong>Liveness</strong>(<code class=\"language-text\">/actuator/health/liveness</code>)는 \"이 프로세스가 살아있는가\"만 판단한다. PING 하나면 충분하다. JVM이 죽었거나 응답 불가 상태인지만 체크한다.</p>\n<p><strong>Readiness</strong>(<code class=\"language-text\">/actuator/health/readiness</code>)는 \"이 서버가 트래픽을 받을 준비가 됐는가\"를 판단한다. DB 연결, Redis 연결, Graceful Shutdown 상태, Redis Stream Container 상태를 모두 확인한다.</p>\n<p>이 분리가 중요한 이유는 <strong>Docker HEALTHCHECK와 로드밸런서가 서로 다른 관심사를 갖기 때문</strong>이다. Docker는 \"컨테이너를 재시작할지\"를 결정해야 하고, 로드밸런서는 \"이 인스턴스에 트래픽을 보낼지\"를 결정해야 한다. 하나의 엔드포인트로 두 가지를 모두 판단하면 의도하지 않은 동작이 발생할 수 있다.</p>\n<p>ZZOL에서는 Docker HEALTHCHECK가 readiness 엔드포인트를 사용하도록 설정했다. 이유는 단순하다. 현재 단일 인스턴스 구조이기 때문에, liveness 체크만으로는 부족하고, readiness 수준의 체크가 컨테이너 재시작 판단에 더 적합하다고 판단했다. 멀티 인스턴스 + 로드밸런서 구조로 전환하면, Docker는 liveness를, 로드밸런서는 readiness를 사용하도록 분리할 수 있다.</p>\n<h2>결과: /actuator/health/readiness 응답</h2>\n<p>적용 후 readiness 엔드포인트의 응답은 다음과 같은 구조가 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"UP\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"components\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"db\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"UP\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"redis\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"UP\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"gracefulShutdown\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"UP\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"redisStream\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"UP\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"details\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"room\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"RUNNING\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"room:join\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"RUNNING\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"cardgame:select\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"RUNNING\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"minigame\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"RUNNING\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"racinggame\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"RUNNING\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>기본 헬스체크만 사용할 때와 비교하면, Graceful Shutdown 진행 여부와 Redis Stream 이벤트 처리 상태를 추가로 감지할 수 있게 됐다.</p>\n<table>\n<thead>\n<tr>\n<th>Before</th>\n<th>After</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DB 연결, Redis PING, 디스크만 체크</td>\n<td>+ Graceful Shutdown 상태, Redis Stream Container 상태</td>\n</tr>\n<tr>\n<td>종료 중에도 UP → 새 트래픽 유입</td>\n<td>종료 중 OUT_OF_SERVICE → 트래픽 차단</td>\n</tr>\n<tr>\n<td>Stream Container 멈추면 즉시 서버 재시작</td>\n<td>내부 복구 2회 시도 → 실패 시에만 재시작</td>\n</tr>\n<tr>\n<td>단일 엔드포인트</td>\n<td>liveness/readiness 그룹 분리</td>\n</tr>\n</tbody>\n</table>\n<h2>정리</h2>\n<p>HealthIndicator에 뭘 넣을지의 기준은 \"재시작으로 복구 가능한가\"였다. 재시작으로 해결되는 문제는 HealthIndicator가 DOWN을 반환해서 자동 복구를 트리거하고, 재시작으로 해결 안 되는 문제는 알림으로 사람에게 알려야 한다. 그리고 의도적인 서비스 중단(Graceful Shutdown)은 DOWN도 아니고 UP도 아닌 OUT_OF_SERVICE로 표현해야, 재시작과 종료가 충돌하지 않는다.</p>\n<p>단, Docker 재시작은 최후의 보루여야 한다. 단일 인스턴스에서 컨테이너 재시작은 100% 다운타임이다. 애플리케이션 내부에서 먼저 복구를 시도하고, 그래도 안 될 때만 외부 인프라에 의한 재시작을 허용하는 구조가 올바른 단계적 복구 전략이다.</p>","frontmatter":{"title":"HealthIndicator에는 무엇을 담아야 하는가: 상태 판별부터 자가 치유까지","date":"2026년 02월 19일 09:02","updated":"2026년 02월 26일 20:02","tags":["ZZOL"],"series":"ZZOL 개발록"},"fields":{"slug":"/custom_health_check/","readingTime":{"minutes":17.625}}},"seriesList":{"edges":[{"node":{"id":"73de1c69-ae7d-5f22-86dc-b52b20e3b407","fields":{"slug":"/ideation/"},"frontmatter":{"title":"사이드 프로젝트에서 실제 서비스까지: 커피빵 기획과 그 시작"}}},{"node":{"id":"9ea2ee9a-0be2-5dc7-997c-93ab924014eb","fields":{"slug":"/persona/"},"frontmatter":{"title":"누가 우리 서비스를 쓸까? : 페르소나 정의를 통한 타겟 유저 구체화"}}},{"node":{"id":"11058e07-9e58-5f4b-a3a1-62d8527031ea","fields":{"slug":"/how_spring_handles_websocket/"},"frontmatter":{"title":"Spring WebSocket 내부 동작 원리 파헤치기"}}},{"node":{"id":"4c6a7cab-3c43-59bf-a541-9ae287bd3a70","fields":{"slug":"/websocket_reconnection_app_switching/"},"frontmatter":{"title":"모바일 백그라운드 전환 시에도 끊김 없는 WebSocket 연결 경험 만들기"}}},{"node":{"id":"ff05890c-ec4a-5029-bd93-4b8cfa5283b4","fields":{"slug":"/thread_pool_tuning/"},"frontmatter":{"title":"스레드풀, 감으로 잡지 마세요: 부하 테스트로 증명하는 최적의 설정값"}}},{"node":{"id":"82f18340-6032-5dac-9b60-50fb8eea635a","fields":{"slug":"/infra_design/"},"frontmatter":{"title":"단일 서버에서 분산 환경으로: 확장성 있는 아키텍처로의 전환"}}},{"node":{"id":"70183ac3-6408-5d91-a2e9-ac740e347ba2","fields":{"slug":"/how_redis_pubsub_works/"},"frontmatter":{"title":"Redis Pub/Sub을 활용한 다중 서버 간 실시간 메시지 동기화 전략"}}},{"node":{"id":"83a93b64-43b3-5668-8afb-b78d831aaf5a","fields":{"slug":"/coffeeshout_to_zzol/"},"frontmatter":{"title":"커피빵에서 ZZOL로, 유저가 알려준 진짜 서비스"}}},{"node":{"id":"7128f864-794b-58de-88f8-282b8ef949b4","fields":{"slug":"/graceful_shutdown/"},"frontmatter":{"title":"WebSocket 서비스에서 Graceful Shutdown이 필요한 이유와 구현"}}},{"node":{"id":"18a2d427-8f34-5a11-baf6-b0687d3a302c","fields":{"slug":"/query_improvement/"},"frontmatter":{"title":"쿼리 최적화, 36초를 1초로 줄이기까지"}}},{"node":{"id":"00644959-42d4-576a-869d-c1fbcfaec633","fields":{"slug":"/message_recovery/"},"frontmatter":{"title":"네트워크 불안정 상황에서도 메시지 유실 없는 견고한 게임 서버 설계"}}},{"node":{"id":"f47bb328-9638-5c53-be0a-416cc9735b4a","fields":{"slug":"/circuit_breaker/"},"frontmatter":{"title":"외부 서비스 장애로부터 살아남기"}}},{"node":{"id":"02e10cb7-26d6-5d3d-939f-c14571d42969","fields":{"slug":"/rate_limiting/"},"frontmatter":{"title":"ZZOL의 효율적인 서버 자기보호 전략"}}},{"node":{"id":"9ee459e1-d77e-53e2-83d1-cb928b7cc908","fields":{"slug":"/custom_health_check/"},"frontmatter":{"title":"HealthIndicator에는 무엇을 담아야 하는가: 상태 판별부터 자가 치유까지"}}},{"node":{"id":"a10e5e75-ed21-5f31-ae69-9b153741f0d8","fields":{"slug":"/disability_simulation/"},"frontmatter":{"title":"\"재시작하면 고쳐져요\"라는 말을 없애기까지: 3단계 서버 자가 치유기"}}},{"node":{"id":"3da5ed5a-c60c-51d8-8bee-b4ea162abb20","fields":{"slug":"/distributed_lock_and_race_condition/"},"frontmatter":{"title":"분산 락의 함정: 락을 걸었는데도 이벤트가 두 번 처리된 이유"}}}]},"previous":{"fields":{"slug":"/rate_limiting/"},"frontmatter":{"title":"ZZOL의 효율적인 서버 자기보호 전략"}},"next":{"fields":{"slug":"/disability_simulation/"},"frontmatter":{"title":"\"재시작하면 고쳐져요\"라는 말을 없애기까지: 3단계 서버 자가 치유기"}}},"pageContext":{"id":"9ee459e1-d77e-53e2-83d1-cb928b7cc908","series":"ZZOL 개발록","previousPostId":"02e10cb7-26d6-5d3d-939f-c14571d42969","nextPostId":"a10e5e75-ed21-5f31-ae69-9b153741f0d8"}},"staticQueryHashes":[],"slicesMap":{}}