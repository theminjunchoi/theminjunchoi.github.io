{"componentChunkName":"component---src-templates-post-jsx","path":"/websocket_reconnection_app_switching/","result":{"data":{"site":{"siteMetadata":{"title":"minjun.blog"}},"markdownRemark":{"id":"9661b2d5-0110-5af9-aedb-86141ccf0b8d","excerpt":"문제 상황 mvp를 빠르게 만들고 테스트를 하던 중, 다른 앱을 사용하다가 다시 돌아오면 웹소켓 통신이 안된다는 것을 발견했다. 찾아보니 모바일이든 pc의 각각의 기기에서 앱을 전환할 때 환경에 맞게 백그라운드에서 웹소켓을 유지하는 시간이 달랐고, 테스트를 결과 아이폰이나 맥북 기준 대부분 4~5초이내로 연결이 중단되는 것 같다. 또 클라이언트 코드에서도…","html":"<h2>문제 상황</h2>\n<p>mvp를 빠르게 만들고 테스트를 하던 중, <strong>다른 앱을 사용하다가 다시 돌아오면 웹소켓 통신이 안된다</strong>는 것을 발견했다.</p>\n<p>찾아보니 모바일이든 pc의 각각의 기기에서 앱을 전환할 때 환경에 맞게 백그라운드에서 웹소켓을 유지하는 시간이 달랐고, 테스트를 결과 아이폰이나 맥북 기준 대부분 4~5초이내로 연결이 중단되는 것 같다.</p>\n<p>또 클라이언트 코드에서도 백그라운드 감지 로직이 없어서, OS에 의해 웹소켓이 연결 해제되면 감지조차 못했다.</p>\n<p>서버에서도 이렇게 연결이 끊어지고 구독이 해제되면, <code class=\"language-text\">SimpleBrokerMessageHandler</code>의 <code class=\"language-text\">SubscriptionRegistry</code>에 저장되어있던 구독정보가 자동으로 제거되기 때문에 서버가 클라이언트에게 메시지를 보낼 수 없게 된다.</p>\n<p>또 문제는 그렇게 재연결을 하려고 할 때 사용되는 세션 id가 기존에 사용하던 id가 아니어서 서버에서는 다른 세션 id이지만, 기존에 있던 사용자인지 알 수 있어야했다.</p>\n<h2>요구사항</h2>\n<p>앱 전환 시에도 사용자는 안정적으로 서비스를 이용할 수 있어야한다.</p>\n<h3>세부 요구사항</h3>\n<ul>\n<li>클라이언트는 서비스의 백 -> 포그라운드 전환을 감지해서 연결을 재요청해줘야한다.</li>\n<li>서버는 다른 세션id를 들고 오는 클라이언트를 보고, 기존의 플레이어와 연동해줘야한다.</li>\n</ul>\n<h2>전처리</h2>\n<h3>사용자와 player를 어떻게 관리할까?</h3>\n<p>현재 우리 서비스에서는 player를 구분할 수 있는 id인 고유식별자가 존재하지 않는다. DB를 사용하고 있지도 않고, player끼리의 구분이 필요한 상황이 없어서 id를 도입하지 않았다.</p>\n<p>대신 <code class=\"language-text\">joinCode:playerName</code>의 형식으로 room의 joinCode와 player의 playerName을 합성키처럼 활용했다. 그리고 웹소켓 연결시에 필요한 <code class=\"language-text\">sessionId</code>도 관리를 해주고 있어야 연결 재요청시에 해당 사용자가 기존 플레이어인지 구분을 할 수 있었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 플레이어 세션 매핑 관리  </span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> playerSessionMap<span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"joinCode:playerName\" -> sessionId  </span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> sessionPlayerMap<span class=\"token punctuation\">;</span> <span class=\"token comment\">// sessionId -> \"joinCode:playerName\"</span></code></pre></div>\n<h3>Disconnect가 감지되면?</h3>\n<p>우선 서버에서 가장 먼저 서버에서 해줘야했던 건 Disconnect가 감지되면 room에서 해당 player를 제거해줘야했다. 그 사용자가 Disconnect 되어도 해당 room에 있던 다른 사용자들은 서비스를 계속 이용할 수 있어야했기에, Disconnect된 player 감지 및 제거가 필수였다.</p>\n<p>웹소켓 연결이 끊어지면 클라이언트로부터 Disconnect 메시지가 온다. 이를 서버가 받을 수 있는데, 이와 같은 메시지를 받는 과정은 <a href=\"/how_spring_handles_websocket\" data-wiki-link=\"true\">how_spring_handles_websocket</a>를 참고하면 좋다!</p>\n<p><strong>'서버에서 Disconnect를 감지하면, 어느 단계에서 player를 room에서 지워줘야할까?'를 많이 고민했다.</strong> 그 과정에서 웹소켓을 구현한 Spring의 내부 구조를 많이 고민하고 실험을 했었는데, 지금까지 연결해제와 관련해서 정리된 내용은 아래와 같다!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">클라이언트가 DISCONNECT 프레임 전송\n\t↓ \nPreSend 인터셉터 실행 (DISCONNECT 메시지 처리 전)\n\t↓ \n메시지 브로커가 DISCONNECT 프레임 처리 (라우팅은 없고 연결 종료 준비)\n\t↓ \nPostSend 인터셉터 실행 (DISCONNECT 메시지 처리 후)\n\t↓ \nTCP WebSocket 연결 종료\n\t↓ \nSubProtocolWebSocketHandler.afterConnectionClosed() ← WebSocket 레벨\n\t↓ \nclearSession() 호출\n\t↓ \nStompSubProtocolHandler.afterSessionEnded() ← STOMP 프로토콜 레벨\n\t↓ \nSessionDisconnectEvent 발행 </code></pre></div>\n<p>이중에서 처음에는 postSend에서 player 제거를 구현했었다. 하지만 Interceptor의 주목적에 맞게 사용하는 것도 아니었고, Spring에서 tcp 소켓 연결 해제를 판단하는 시점보다 빨라서 정합성이 깨질 수도 있을 거라 생각했다. 또한 얼마전에 브라우저가 강제종료 됐을 때 클라이언트가 Disconnect 프레임을 전송하지도 못하고 바로 tcp 연결이 끊기면서 room에서 player가 제거되지 않는 문제도 발견했다.</p>\n<p>그래서 좀 더 살펴보니, Spring 내부에서 완전히 tcp 소켓이 끊어지면, STOMP 연결해제를 감지하고 자동으로 SessionDisconnectEvent을 발행해주고 있었고,  이를 잡아서 room에서 player를 지워주는 게 더 적절한 시점에 처리하는 것이라고 판단했다.</p>\n<h2>첫 번째 시도, 클라이언트 코드에서만 재연결을 추가해주면?</h2>\n<p>서버에서는 위에서 말한 것처럼 Disconnect가 감지되면 바로 room에서 player를 지워줬다.</p>\n<p>클라이언트 코드에서는 Page Visibility API를 사용해서 사용 중이던 서비스가 백그라운드에서 포그라운도 전환됐을 때를 감지해서 그 시점에 클라이언트가 서버로 웹소켓 연결을 재요청하도록 추가했다.</p>\n<p>서버에서는 연결 요청시에 오는 메시지의 헤더에 담긴 joinCode와 playerName을 보고 적절한 room을 찾아서 다시 player 객체를 만들어서 추가시켜줬다.</p>\n<h3>뭔가 어색하다.</h3>\n<p>잘 작동하긴 했다. 하지만 좀 어색하게 느껴졌던 건, 사용자가 앱 전환을 하자마자 room에서 player가 사라지는 모습이었다.</p>\n<p>다른 여타 비슷한 류의 게임을 살펴보면, 배틀그라운드든, 오버워치든, 텐텐이든 사용자가 앱 전환을 했을 때 바로 튕기게끔 하는 게 아니라 조금의 유예 시간을 주고, 그래도 사용자가 돌아오지 않았을 때 나가게 처리하는 모습을 볼 수 있었다.</p>\n<p>우리 서비스도 참고해보려고 했다.</p>\n<h2>두 번째 시도, 15초의 유예 시간을 주자</h2>\n<p>사용자의 Disconnect가 감지되면 조금의 유예 시간을 주도록 했다. joinCode를 다른 서비스에 공유하러 나가거나, 급한 알림을 확인하는 등의 상황을 고려했다. 그렇게 15초의 여유 시간을 줬고, 그 시간 안에도 서비스로 안돌아오면 room에서 player를 제거해주었다.</p>\n<p>이를 구현하기 위해 ScheduledFuture를 이용했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">schedulePlayerRemoval</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> playerKey<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> sessionId<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> reason<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n    log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"플레이어 지연 삭제 스케줄링: playerKey={}, sessionId={}, delay={}초\"</span><span class=\"token punctuation\">,</span>  \n            playerKey<span class=\"token punctuation\">,</span> sessionId<span class=\"token punctuation\">,</span> <span class=\"token constant\">REMOVAL_DELAY</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n  \n    <span class=\"token comment\">// disconnect 된 플레이어는 ready 상태 false로 변경  </span>\n    playerDisconnectionService<span class=\"token punctuation\">.</span><span class=\"token function\">cancelReady</span><span class=\"token punctuation\">(</span>playerKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n  \n    <span class=\"token comment\">// 새로운 스케줄 등록  </span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">ScheduledFuture</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span> future <span class=\"token operator\">=</span> taskScheduler<span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span>  \n            <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>  \n                <span class=\"token function\">executePlayerRemoval</span><span class=\"token punctuation\">(</span>playerKey<span class=\"token punctuation\">,</span> sessionId<span class=\"token punctuation\">,</span> reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n                stompSessionManager<span class=\"token punctuation\">.</span><span class=\"token function\">removeSession</span><span class=\"token punctuation\">(</span>sessionId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>  \n            <span class=\"token class-name\">Instant</span><span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">plus</span><span class=\"token punctuation\">(</span><span class=\"token constant\">REMOVAL_DELAY</span><span class=\"token punctuation\">)</span>  \n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n  \n    scheduledTasks<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>playerKey<span class=\"token punctuation\">,</span> future<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그래서 잠시 앱을 전환하더라도 room에는 player가 남아있고, 대신 그렇게 잠시 나가있을 땐 host가 게임을 시작하지 못하도록 해줬다.</p>\n<h2>TODO</h2>\n<p>웹소켓은 네트워크 연결 방식이 바뀔 때도 연결이 끊기고, 새로운 세션id가 발급된다. 이런 상황은 앱 전환과 다르게 사용자가 컨트롤하지 못하는 상황도 있을거라 생각이 들어서 이 이슈도 우선적으로 해결해야할 것 같다.</p>\n<p>이 문제를 해결하면서, 게임 중에 연결이 끊기는 경우 게임시간을 어떻게 다시 전파해야할지, 끊긴 과정에서 못받은 메시지들은 어떻게 다시 전달해줘야할지 고민할 수 있을 것 같다.</p>","frontmatter":{"title":"모바일 백그라운드 전환 시에도 끊김 없는 WebSocket 연결 경험 만들기","date":"2025년 08월 13일 09:08","updated":"2026년 02월 18일 03:02","tags":["우아한테크코스","ZZOL"],"series":"ZZOL 개발록"},"fields":{"slug":"/websocket_reconnection_app_switching/","readingTime":{"minutes":9.715}}},"seriesList":{"edges":[{"node":{"id":"dc0a8329-79ba-55f1-a688-c2f7cbe3f8fd","fields":{"slug":"/ideation/"},"frontmatter":{"title":"사이드 프로젝트에서 실제 서비스까지: 커피빵 기획과 그 시작"}}},{"node":{"id":"b8d473fd-79ee-51d9-ae2b-71c19291cb0e","fields":{"slug":"/persona/"},"frontmatter":{"title":"누가 우리 서비스를 쓸까? : 페르소나 정의를 통한 타겟 유저 구체화"}}},{"node":{"id":"17ea11c4-1553-5ec0-9e45-75f970e28462","fields":{"slug":"/how_spring_handles_websocket/"},"frontmatter":{"title":"Spring WebSocket 내부 동작 원리 파헤치기"}}},{"node":{"id":"9661b2d5-0110-5af9-aedb-86141ccf0b8d","fields":{"slug":"/websocket_reconnection_app_switching/"},"frontmatter":{"title":"모바일 백그라운드 전환 시에도 끊김 없는 WebSocket 연결 경험 만들기"}}},{"node":{"id":"d83add12-9f50-5d42-a371-f347258c1a37","fields":{"slug":"/thread_pool_tuning/"},"frontmatter":{"title":"스레드풀, 감으로 잡지 마세요: 부하 테스트로 증명하는 최적의 설정값"}}},{"node":{"id":"dec80c60-9cbd-54f2-8aae-62e15b54c78f","fields":{"slug":"/infra_design/"},"frontmatter":{"title":"단일 서버에서 분산 환경으로: 확장성 있는 아키텍처로의 전환"}}},{"node":{"id":"3fd12d05-6c82-5d61-91c5-732734d90aa2","fields":{"slug":"/how_redis_pubsub_works/"},"frontmatter":{"title":"Redis Pub/Sub을 활용한 다중 서버 간 실시간 메시지 동기화 전략"}}},{"node":{"id":"deb7290a-38ec-5ac8-a608-ff8d0903f9bb","fields":{"slug":"/coffeeshout_to_zzol/"},"frontmatter":{"title":"커피빵에서 ZZOL로, 유저가 알려준 진짜 서비스"}}},{"node":{"id":"cdc783fb-1df1-5d09-a998-412d8decc001","fields":{"slug":"/graceful_shutdown/"},"frontmatter":{"title":"WebSocket 서비스에서 Graceful Shutdown이 필요한 이유와 구현"}}},{"node":{"id":"e261d9ca-4bb4-5c6a-9d1d-054586acbf8c","fields":{"slug":"/query_improvement/"},"frontmatter":{"title":"쿼리 최적화, 36초를 1초로 줄이기까지"}}},{"node":{"id":"d9f071be-73c0-5fae-9976-1c75172a66b8","fields":{"slug":"/message_recovery/"},"frontmatter":{"title":"네트워크 불안정 상황에서도 메시지 유실 없는 견고한 게임 서버 설계"}}},{"node":{"id":"ee902985-b17e-5dda-8226-5be551279e64","fields":{"slug":"/circuit_breaker/"},"frontmatter":{"title":"외부 서비스 장애로부터 살아남기"}}},{"node":{"id":"f1722009-fa42-55ae-acb7-d4b6627dba94","fields":{"slug":"/rate_limiting/"},"frontmatter":{"title":"ZZOL의 효율적인 서버 자기보호 전략"}}}]},"previous":{"fields":{"slug":"/how_spring_handles_websocket/"},"frontmatter":{"title":"Spring WebSocket 내부 동작 원리 파헤치기"}},"next":{"fields":{"slug":"/우아한테크코스_7기_BE_레벨3_회고/"},"frontmatter":{"title":"우아한테크코스 7기 BE 레벨3 회고"}}},"pageContext":{"id":"9661b2d5-0110-5af9-aedb-86141ccf0b8d","series":"ZZOL 개발록","previousPostId":"17ea11c4-1553-5ec0-9e45-75f970e28462","nextPostId":"e9fec65a-dfe8-5e60-ba50-fd4cf47e1536"}},"staticQueryHashes":[],"slicesMap":{}}