{"componentChunkName":"component---src-templates-post-jsx","path":"/disability_simulation/","result":{"data":{"site":{"siteMetadata":{"title":"minjun.blog"}},"markdownRemark":{"id":"a10e5e75-ed21-5f31-ae69-9b153741f0d8","excerpt":"custom_health_check 글에서 커스텀 HealthIndicator와 3단계 자가복구 계층을 설계했다. 이 글에서는 dev 환경에서 5가지 장애 시나리오를 재현하여 복구 계층이 의도대로 동작하는지 검증한 과정을 기록한다. 왜 시뮬레이션이 필요한가 이전 글에서 설계한 복구 계층은 이렇다. 설계 시점에는 \"이렇게 동작할 것이다\"라는 가정이었다. R…","html":"<p><a href=\"/custom_health_check\" data-wiki-link=\"true\">custom_health_check</a> 글에서 커스텀 HealthIndicator와 3단계 자가복구 계층을 설계했다. 이 글에서는 dev 환경에서 5가지 장애 시나리오를 재현하여 복구 계층이 의도대로 동작하는지 검증한 과정을 기록한다.</p>\n<h2>왜 시뮬레이션이 필요한가</h2>\n<p>이전 글에서 설계한 복구 계층은 이렇다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Failure]\n    |\n    v\nLevel 0: Lettuce auto-reconnect (ms~sec outage)\n    |\n    v  (if Container stopped)\nLevel 1: Recovery container.start() (max 2 attempts)\n    |\n    v  (if Recovery failed)\nLevel 2: Docker restart (last resort)</code></pre></div>\n<p>설계 시점에는 \"이렇게 동작할 것이다\"라는 가정이었다. Recovery의 30초 주기, 2회 연속 실패 판정, failure count 초기화 같은 세부 동작은 단위 테스트로 로직은 검증할 수 있지만, Lettuce 재연결 → Stream Container 상태 변화 → Recovery 감지 → HealthIndicator 전환 → Docker HEALTHCHECK 반응이라는 전체 체인은 실제 인프라에서 돌려봐야 알 수 있다.</p>\n<h2>시뮬레이션 방법의 선택</h2>\n<p>장애를 재현하는 방법에는 세 가지가 있다.</p>\n<p><code class=\"language-text\">docker stop</code>은 Redis에 SIGTERM을 보내서 깨끗하게 종료시킨다. TCP RST 패킷이 전달되므로 Lettuce가 즉시 연결 끊김을 인지한다. <code class=\"language-text\">iptables DROP</code>은 Redis 포트의 패킷을 무조건 버린다. 커넥션은 살아있는데 응답이 안 오는 상황(Network Blackhole)을 만든다. Lettuce는 command timeout(60초)이 만료될 때까지 스레드가 블로킹된다. <code class=\"language-text\">tc</code>(Traffic Control)는 지연, 패킷 유실률 등을 세밀하게 조절할 수 있다.</p>\n<p><code class=\"language-text\">docker stop</code>을 선택했다. 운영에서 가장 무서운 장애는 네트워크 파티션(Blackhole)이지만, 이번 시뮬레이션의 목적은 \"Recovery → HealthIndicator → Docker HEALTHCHECK\" 체인의 동작 검증이다. 네트워크 파티션은 Lettuce의 timeout 동작과 스레드 풀 고갈까지 범위가 확장되므로, 복구 체인 검증과 별개의 주제로 분리했다.</p>\n<p><code class=\"language-text\">docker stop</code>으로 검증할 수 없는 것은 명확하다. 패킷이 유실되어 Lettuce가 timeout까지 블로킹되는 동안 애플리케이션의 스레드 풀과 커넥션 풀이 어떻게 되는지, 그리고 그 상태에서 Recovery가 제때 개입할 수 있는지는 별도 시뮬레이션이 필요하다.</p>\n<h2>시나리오 1: Redis 일시적 중단 — Level 0에서 흡수</h2>\n<p>Redis를 3초간 중단했다가 재시작했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> stop dev-redis <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sleep</span> <span class=\"token number\">3</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">docker</span> start dev-redis</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td><code class=\"language-text\">docker stop dev-redis</code></td>\n</tr>\n<tr>\n<td>T+3s</td>\n<td><code class=\"language-text\">docker start dev-redis</code></td>\n</tr>\n<tr>\n<td>T+5s</td>\n<td>Lettuce <code class=\"language-text\">Reconnected to dev-redis</code></td>\n</tr>\n<tr>\n<td>T+30s</td>\n<td>Recovery 주기 도달. <code class=\"language-text\">container.isRunning()</code> = true. 개입 없음</td>\n</tr>\n</tbody>\n</table>\n<p>Recovery가 개입하지 않았다. <code class=\"language-text\">docker stop</code>으로 Redis 프로세스가 종료되면 TCP 연결이 즉시 끊어지므로, Lettuce는 타임아웃(60초)을 기다리지 않고 즉각적으로 연결 끊김을 감지하고 자체 재연결을 시도한다. Redis가 3초 만에 다시 띄워졌고 Lettuce가 재연결을 완료했기 때문에, 30초 주기로 도는 Recovery 스케줄러가 개입할 틈이 없었다.</p>\n<p>처음에는 \"Recovery가 동작해야 검증이 되는 거 아닌가?\"라고 생각했다. 하지만 이것 자체가 중요한 검증이다. 짧은 Redis 중단은 Level 0(Lettuce)에서 흡수되므로, Recovery(Level 1)까지 갈 필요가 없다. 복구 계층이 \"필요할 때만 개입한다\"는 설계를 확인한 것이다.</p>\n<h2>시나리오 2: Redis 장기 중단 → Recovery 자가복구 성공</h2>\n<p>Redis를 30초간 중단한 뒤 재시작.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> stop dev-redis\n<span class=\"token comment\"># ... 30초 대기 ...</span>\n<span class=\"token function\">docker</span> start dev-redis\n<span class=\"token comment\"># ... 30초 대기 (Recovery 다음 주기) ...</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td><code class=\"language-text\">docker stop dev-redis</code></td>\n</tr>\n<tr>\n<td>T+1s</td>\n<td>Lettuce <code class=\"language-text\">Reconnecting</code> 반복</td>\n</tr>\n<tr>\n<td>T+30s</td>\n<td><code class=\"language-text\">docker start dev-redis</code></td>\n</tr>\n<tr>\n<td>T+32s</td>\n<td>Lettuce <code class=\"language-text\">Reconnected</code></td>\n</tr>\n<tr>\n<td>T+60s</td>\n<td>Recovery: Stream Container STOPPED 감지 → <code class=\"language-text\">container.start()</code> 성공</td>\n</tr>\n<tr>\n<td>T+60s</td>\n<td><code class=\"language-text\">recoveryFailureCounts</code> 초기화. HealthIndicator UP 유지</td>\n</tr>\n</tbody>\n</table>\n<p>Recovery가 <code class=\"language-text\">container.start()</code>를 호출했고, Redis가 이미 살아있었으므로 1회차에서 즉시 복구됐다. Docker 재시작은 발생하지 않았다. Container 하나 멈춘 건데 서버 전체를 재시작하는 대신, 멈춘 것만 재시작해서 단일 인스턴스의 100% 다운타임을 회피했다.</p>\n<h2>시나리오 3: Redis 장기 중단 → Recovery 실패 → Docker 재시작</h2>\n<p>Redis를 2분 이상 중단한 채로 유지.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> stop dev-redis\n<span class=\"token comment\"># ... 2분+ 대기 ...</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td><code class=\"language-text\">docker stop dev-redis</code></td>\n</tr>\n<tr>\n<td>T+60s</td>\n<td>Recovery 1차: <code class=\"language-text\">container.start()</code> → 실패 (1/2)</td>\n</tr>\n<tr>\n<td>T+90s</td>\n<td>Recovery 2차: <code class=\"language-text\">container.start()</code> → 실패 (2/2)</td>\n</tr>\n<tr>\n<td>T+90s</td>\n<td><code class=\"language-text\">failedRecoveryStreams</code> 등록 → HealthIndicator DOWN</td>\n</tr>\n<tr>\n<td>T+120~180s</td>\n<td>Docker HEALTHCHECK 3회 연속 unhealthy → 컨테이너 재시작</td>\n</tr>\n</tbody>\n</table>\n<p>readiness 응답이 바뀌었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"DOWN\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"components\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"redisStream\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"DOWN\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"details\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"unrecoverable\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"minigame\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"racinggame\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"room\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"room:join\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cardgame:select\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"action\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Internal recovery failed. Docker restart required.\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Recovery로 해결할 수 없는 상황에서만 Level 2(Docker 재시작)가 트리거됐다.</p>\n<h2>시나리오 4: Graceful Shutdown — OUT_OF_SERVICE 확인</h2>\n<p>SIGTERM을 전송하여 Graceful Shutdown 시작.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">kill</span> <span class=\"token parameter variable\">--signal</span><span class=\"token operator\">=</span>SIGTERM dev-app-blue</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td>SIGTERM 수신. readiness: UP → OUT_OF_SERVICE</td>\n</tr>\n<tr>\n<td>T+1s</td>\n<td>WebSocket 세션 드레이닝 시작</td>\n</tr>\n<tr>\n<td>T+~30s</td>\n<td>활성 세션 없음 → 종료 완료</td>\n</tr>\n</tbody>\n</table>\n<p>DOWN이 아니라 OUT_OF_SERVICE이므로 Docker HEALTHCHECK가 재시작을 시도하지 않았고, 세션 드레이닝이 정상 완료됐다. 이전 글에서 DOWN과 OUT_OF_SERVICE를 구분한 설계가 검증된 시나리오다.</p>\n<h2>시나리오 5: Recovery 1차 실패 → Redis 복구 → 2차 성공</h2>\n<p>Recovery의 \"연속 실패\" 판정 로직을 검증하기 위한 경계값 테스트.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> stop dev-redis\n<span class=\"token comment\"># ... 40초 대기 (Recovery 1차 실패 유도) ...</span>\n<span class=\"token function\">docker</span> start dev-redis\n<span class=\"token comment\"># ... 30초 대기 (Recovery 2차 주기) ...</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td><code class=\"language-text\">docker stop dev-redis</code></td>\n</tr>\n<tr>\n<td>T+60s</td>\n<td>Recovery 1차: 실패 (1/2)</td>\n</tr>\n<tr>\n<td>T+70s</td>\n<td><code class=\"language-text\">docker start dev-redis</code></td>\n</tr>\n<tr>\n<td>T+90s</td>\n<td>Recovery 2차: <code class=\"language-text\">container.start()</code> → 성공. failureCount 초기화</td>\n</tr>\n</tbody>\n</table>\n<p>이 시나리오가 중요한 이유는 <code class=\"language-text\">MAX_RECOVERY_ATTEMPTS</code>의 값과 직결되기 때문이다. 처음에는 1로 설정했다. 1번 실패하면 바로 DOWN. 하지만 Redis 재시작이 30초 이상 걸리는 경우(AOF 로드 등) Recovery 1차 시점에 아직 Redis가 안 올라와서 즉시 DOWN → Docker 재시작이 트리거된다. Recovery가 존재하는 의미가 없어진다.</p>\n<p>3으로 올리는 것도 검토했다. 3회면 약 90초의 복구 대기 시간을 확보할 수 있지만, 진짜 복구 불가능한 상황에서 Docker 재시작까지 최소 3분이 걸린다. 단일 인스턴스에서 3분은 너무 길다.</p>\n<p>2회로 결정했다. 약 60초의 복구 대기 시간을 확보하면서, 진짜 안 되는 경우 2분 이내에 Docker 재시작으로 넘어간다. 시나리오 5가 이 판단을 검증한 것이다.</p>\n<h2>종합</h2>\n<table>\n<thead>\n<tr>\n<th>시나리오</th>\n<th>Recovery</th>\n<th>HealthIndicator</th>\n<th>Docker 재시작</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Redis 3초 중단</td>\n<td>미개입 (Lettuce)</td>\n<td>UP</td>\n<td>없음</td>\n</tr>\n<tr>\n<td>Redis 30초 중단 후 복구</td>\n<td>1차 성공</td>\n<td>UP</td>\n<td>없음</td>\n</tr>\n<tr>\n<td>Redis 2분+ 장기 중단</td>\n<td>2차 연속 실패</td>\n<td>DOWN</td>\n<td>발생</td>\n</tr>\n<tr>\n<td>Graceful Shutdown</td>\n<td>미개입</td>\n<td>OUT_OF_SERVICE</td>\n<td>없음</td>\n</tr>\n<tr>\n<td>Redis 40초 중단 후 복구</td>\n<td>1차 실패, 2차 성공</td>\n<td>UP</td>\n<td>없음</td>\n</tr>\n</tbody>\n</table>\n<p>5개 시나리오 중 Docker 재시작(Level 2)이 발생한 건 1개뿐이다. 각 레벨은 이전 레벨이 해결하지 못한 상황에서만 개입한다.</p>\n<h2>정리</h2>\n<p>시뮬레이션 전에는 가정이었고, 시뮬레이션 후에야 검증이 됐다. <code class=\"language-text\">docker stop</code>이라는 단순한 방법이었지만, Recovery → HealthIndicator → Docker HEALTHCHECK 체인의 동작을 확인하기에 충분했다.</p>\n<p><code class=\"language-text\">docker stop</code>으로 검증하지 못한 영역은 남아있다. 네트워크 파티션 상황에서 Lettuce가 timeout까지 블로킹되는 동안 스레드 풀과 커넥션 풀이 어떻게 되는지, Recovery가 제때 개입할 수 있는지는 <code class=\"language-text\">iptables</code> 기반의 별도 시뮬레이션이 필요하다.</p>","frontmatter":{"title":"설계는 검증되어야 한다: 3단계 자가 치유 아키텍처 장애 시뮬레이션","date":"2026년 02월 21일 03:02","updated":"2026년 02월 22일 00:02","tags":["ZZOL"],"series":"ZZOL 개발록"},"fields":{"slug":"/disability_simulation/","readingTime":{"minutes":9.635}}},"seriesList":{"edges":[{"node":{"id":"73de1c69-ae7d-5f22-86dc-b52b20e3b407","fields":{"slug":"/ideation/"},"frontmatter":{"title":"사이드 프로젝트에서 실제 서비스까지: 커피빵 기획과 그 시작"}}},{"node":{"id":"9ea2ee9a-0be2-5dc7-997c-93ab924014eb","fields":{"slug":"/persona/"},"frontmatter":{"title":"누가 우리 서비스를 쓸까? : 페르소나 정의를 통한 타겟 유저 구체화"}}},{"node":{"id":"11058e07-9e58-5f4b-a3a1-62d8527031ea","fields":{"slug":"/how_spring_handles_websocket/"},"frontmatter":{"title":"Spring WebSocket 내부 동작 원리 파헤치기"}}},{"node":{"id":"4c6a7cab-3c43-59bf-a541-9ae287bd3a70","fields":{"slug":"/websocket_reconnection_app_switching/"},"frontmatter":{"title":"모바일 백그라운드 전환 시에도 끊김 없는 WebSocket 연결 경험 만들기"}}},{"node":{"id":"ff05890c-ec4a-5029-bd93-4b8cfa5283b4","fields":{"slug":"/thread_pool_tuning/"},"frontmatter":{"title":"스레드풀, 감으로 잡지 마세요: 부하 테스트로 증명하는 최적의 설정값"}}},{"node":{"id":"82f18340-6032-5dac-9b60-50fb8eea635a","fields":{"slug":"/infra_design/"},"frontmatter":{"title":"단일 서버에서 분산 환경으로: 확장성 있는 아키텍처로의 전환"}}},{"node":{"id":"70183ac3-6408-5d91-a2e9-ac740e347ba2","fields":{"slug":"/how_redis_pubsub_works/"},"frontmatter":{"title":"Redis Pub/Sub을 활용한 다중 서버 간 실시간 메시지 동기화 전략"}}},{"node":{"id":"83a93b64-43b3-5668-8afb-b78d831aaf5a","fields":{"slug":"/coffeeshout_to_zzol/"},"frontmatter":{"title":"커피빵에서 ZZOL로, 유저가 알려준 진짜 서비스"}}},{"node":{"id":"7128f864-794b-58de-88f8-282b8ef949b4","fields":{"slug":"/graceful_shutdown/"},"frontmatter":{"title":"WebSocket 서비스에서 Graceful Shutdown이 필요한 이유와 구현"}}},{"node":{"id":"18a2d427-8f34-5a11-baf6-b0687d3a302c","fields":{"slug":"/query_improvement/"},"frontmatter":{"title":"쿼리 최적화, 36초를 1초로 줄이기까지"}}},{"node":{"id":"00644959-42d4-576a-869d-c1fbcfaec633","fields":{"slug":"/message_recovery/"},"frontmatter":{"title":"네트워크 불안정 상황에서도 메시지 유실 없는 견고한 게임 서버 설계"}}},{"node":{"id":"f47bb328-9638-5c53-be0a-416cc9735b4a","fields":{"slug":"/circuit_breaker/"},"frontmatter":{"title":"외부 서비스 장애로부터 살아남기"}}},{"node":{"id":"02e10cb7-26d6-5d3d-939f-c14571d42969","fields":{"slug":"/rate_limiting/"},"frontmatter":{"title":"ZZOL의 효율적인 서버 자기보호 전략"}}},{"node":{"id":"9ee459e1-d77e-53e2-83d1-cb928b7cc908","fields":{"slug":"/custom_health_check/"},"frontmatter":{"title":"HealthIndicator에는 무엇을 담아야 하는가: 상태 판별부터 자가 치유까지"}}},{"node":{"id":"a10e5e75-ed21-5f31-ae69-9b153741f0d8","fields":{"slug":"/disability_simulation/"},"frontmatter":{"title":"설계는 검증되어야 한다: 3단계 자가 치유 아키텍처 장애 시뮬레이션"}}}]},"previous":{"fields":{"slug":"/custom_health_check/"},"frontmatter":{"title":"HealthIndicator에는 무엇을 담아야 하는가: 상태 판별부터 자가 치유까지"}},"next":null},"pageContext":{"id":"a10e5e75-ed21-5f31-ae69-9b153741f0d8","series":"ZZOL 개발록","previousPostId":"9ee459e1-d77e-53e2-83d1-cb928b7cc908","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}