{"componentChunkName":"component---src-templates-post-jsx","path":"/disability_simulation/","result":{"data":{"site":{"siteMetadata":{"title":"minjun.blog"}},"markdownRemark":{"id":"25efdf37-c886-5257-bde8-1c8d524d0384","excerpt":"[custom_health_check] 글에서 커스텀 HealthIndicator와 3단계 자가복구 계층을 설계했다. 이 글에서는 dev 환경에서 5가지 장애 시나리오를 재현하여 복구 계층이 의도대로 동작하는지 검증한 과정을 기록한다. 왜 시뮬레이션이 필요한가 이전 글에서 설계한 복구 계층은 이렇다. 설계 시점에는 \"이렇게 동작할 것이다\"라는 가정이었다.…","html":"<p>[custom_health_check] 글에서 커스텀 HealthIndicator와 3단계 자가복구 계층을 설계했다. 이 글에서는 dev 환경에서 5가지 장애 시나리오를 재현하여 복구 계층이 의도대로 동작하는지 검증한 과정을 기록한다.</p>\n<h2>왜 시뮬레이션이 필요한가</h2>\n<p>이전 글에서 설계한 복구 계층은 이렇다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Failure]\n    |\n    v\nLevel 0: Lettuce auto-reconnect (ms~sec outage)\n    |\n    v  (if Container stopped)\nLevel 1: Recovery container.start() (max 2 attempts)\n    |\n    v  (if Recovery failed)\nLevel 2: Docker restart (last resort)</code></pre></div>\n<p>설계 시점에는 \"이렇게 동작할 것이다\"라는 가정이었다. Recovery의 30초 주기, 2회 연속 실패 판정, failure count 초기화 같은 세부 동작은 단위 테스트로 로직은 검증할 수 있지만, Lettuce 재연결 → Stream Container 상태 변화 → Recovery 감지 → HealthIndicator 전환 → Docker HEALTHCHECK 반응이라는 전체 체인은 실제 인프라에서 돌려봐야 알 수 있다.</p>\n<h2>시뮬레이션 방법의 선택</h2>\n<p>장애를 재현하는 방법에는 세 가지가 있다.</p>\n<p><code class=\"language-text\">docker stop</code>은 Redis에 SIGTERM을 보내서 깨끗하게 종료시킨다. TCP RST 패킷이 전달되므로 Lettuce가 즉시 연결 끊김을 인지한다. <code class=\"language-text\">iptables DROP</code>은 Redis 포트의 패킷을 무조건 버린다. 커넥션은 살아있는데 응답이 안 오는 상황(Network Blackhole)을 만든다. Lettuce는 command timeout(60초)이 만료될 때까지 스레드가 블로킹된다. <code class=\"language-text\">tc</code>(Traffic Control)는 지연, 패킷 유실률 등을 세밀하게 조절할 수 있다.</p>\n<p><code class=\"language-text\">docker stop</code>을 선택했다. 운영에서 가장 무서운 장애는 네트워크 파티션(Blackhole)이지만, 이번 시뮬레이션의 목적은 \"Recovery → HealthIndicator → Docker HEALTHCHECK\" 체인의 동작 검증이다. 네트워크 파티션은 Lettuce의 timeout 동작과 스레드 풀 고갈까지 범위가 확장되므로, 복구 체인 검증과 별개의 주제로 분리했다.</p>\n<p><code class=\"language-text\">docker stop</code>으로 검증할 수 없는 것은 명확하다. 패킷이 유실되어 Lettuce가 timeout까지 블로킹되는 동안 애플리케이션의 스레드 풀과 커넥션 풀이 어떻게 되는지, 그리고 그 상태에서 Recovery가 제때 개입할 수 있는지는 별도 시뮬레이션이 필요하다.</p>\n<h2>시나리오 1: Redis 일시적 중단 — Level 0에서 흡수</h2>\n<p>Redis를 3초간 중단했다가 재시작했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> stop dev-redis <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">sleep</span> <span class=\"token number\">3</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">docker</span> start dev-redis</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td><code class=\"language-text\">docker stop dev-redis</code></td>\n</tr>\n<tr>\n<td>T+3s</td>\n<td><code class=\"language-text\">docker start dev-redis</code></td>\n</tr>\n<tr>\n<td>T+5s</td>\n<td>Lettuce <code class=\"language-text\">Reconnected to dev-redis</code></td>\n</tr>\n<tr>\n<td>T+30s</td>\n<td>Recovery 주기 도달. <code class=\"language-text\">container.isRunning()</code> = true. 개입 없음</td>\n</tr>\n</tbody>\n</table>\n<p>Recovery가 개입하지 않았다. Redis 중단 시간(3초)이 Lettuce command timeout(60초)보다 짧아서 Stream Container가 멈추기 전에 Lettuce가 자체 재연결을 완료했다.</p>\n<p>처음에는 \"Recovery가 동작해야 검증이 되는 거 아닌가?\"라고 생각했다. 하지만 이것 자체가 중요한 검증이다. 짧은 Redis 중단은 Level 0(Lettuce)에서 흡수되므로, Recovery(Level 1)까지 갈 필요가 없다. 복구 계층이 \"필요할 때만 개입한다\"는 설계를 확인한 것이다.</p>\n<h2>시나리오 2: Redis 장기 중단 → Recovery 자가복구 성공</h2>\n<p>Redis를 30초간 중단한 뒤 재시작.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> stop dev-redis\n<span class=\"token comment\"># ... 30초 대기 ...</span>\n<span class=\"token function\">docker</span> start dev-redis\n<span class=\"token comment\"># ... 30초 대기 (Recovery 다음 주기) ...</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td><code class=\"language-text\">docker stop dev-redis</code></td>\n</tr>\n<tr>\n<td>T+1s</td>\n<td>Lettuce <code class=\"language-text\">Reconnecting</code> 반복</td>\n</tr>\n<tr>\n<td>T+30s</td>\n<td><code class=\"language-text\">docker start dev-redis</code></td>\n</tr>\n<tr>\n<td>T+32s</td>\n<td>Lettuce <code class=\"language-text\">Reconnected</code></td>\n</tr>\n<tr>\n<td>T+60s</td>\n<td>Recovery: Stream Container STOPPED 감지 → <code class=\"language-text\">container.start()</code> 성공</td>\n</tr>\n<tr>\n<td>T+60s</td>\n<td><code class=\"language-text\">recoveryFailureCounts</code> 초기화. HealthIndicator UP 유지</td>\n</tr>\n</tbody>\n</table>\n<p>Recovery가 <code class=\"language-text\">container.start()</code>를 호출했고, Redis가 이미 살아있었으므로 1회차에서 즉시 복구됐다. Docker 재시작은 발생하지 않았다. Container 하나 멈춘 건데 서버 전체를 재시작하는 대신, 멈춘 것만 재시작해서 단일 인스턴스의 100% 다운타임을 회피했다.</p>\n<h2>시나리오 3: Redis 장기 중단 → Recovery 실패 → Docker 재시작</h2>\n<p>Redis를 2분 이상 중단한 채로 유지.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> stop dev-redis\n<span class=\"token comment\"># ... 2분+ 대기 ...</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td><code class=\"language-text\">docker stop dev-redis</code></td>\n</tr>\n<tr>\n<td>T+60s</td>\n<td>Recovery 1차: <code class=\"language-text\">container.start()</code> → 실패 (1/2)</td>\n</tr>\n<tr>\n<td>T+90s</td>\n<td>Recovery 2차: <code class=\"language-text\">container.start()</code> → 실패 (2/2)</td>\n</tr>\n<tr>\n<td>T+90s</td>\n<td><code class=\"language-text\">failedRecoveryStreams</code> 등록 → HealthIndicator DOWN</td>\n</tr>\n<tr>\n<td>T+120~180s</td>\n<td>Docker HEALTHCHECK 3회 연속 unhealthy → 컨테이너 재시작</td>\n</tr>\n</tbody>\n</table>\n<p>readiness 응답이 바뀌었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"DOWN\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"components\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"redisStream\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"DOWN\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"details\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"unrecoverable\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"minigame\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"racinggame\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"room\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"room:join\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cardgame:select\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"action\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Internal recovery failed. Docker restart required.\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Recovery로 해결할 수 없는 상황에서만 Level 2(Docker 재시작)가 트리거됐다.</p>\n<h2>시나리오 4: Graceful Shutdown — OUT_OF_SERVICE 확인</h2>\n<p>SIGTERM을 전송하여 Graceful Shutdown 시작.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">kill</span> <span class=\"token parameter variable\">--signal</span><span class=\"token operator\">=</span>SIGTERM dev-app-blue</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td>SIGTERM 수신. readiness: UP → OUT_OF_SERVICE</td>\n</tr>\n<tr>\n<td>T+1s</td>\n<td>WebSocket 세션 드레이닝 시작</td>\n</tr>\n<tr>\n<td>T+~30s</td>\n<td>활성 세션 없음 → 종료 완료</td>\n</tr>\n</tbody>\n</table>\n<p>DOWN이 아니라 OUT_OF_SERVICE이므로 Docker HEALTHCHECK가 재시작을 시도하지 않았고, 세션 드레이닝이 정상 완료됐다. 이전 글에서 DOWN과 OUT_OF_SERVICE를 구분한 설계가 검증된 시나리오다.</p>\n<h2>시나리오 5: Recovery 1차 실패 → Redis 복구 → 2차 성공</h2>\n<p>Recovery의 \"연속 실패\" 판정 로직을 검증하기 위한 경계값 테스트.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> stop dev-redis\n<span class=\"token comment\"># ... 40초 대기 (Recovery 1차 실패 유도) ...</span>\n<span class=\"token function\">docker</span> start dev-redis\n<span class=\"token comment\"># ... 30초 대기 (Recovery 2차 주기) ...</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>시각</th>\n<th>이벤트</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T+0s</td>\n<td><code class=\"language-text\">docker stop dev-redis</code></td>\n</tr>\n<tr>\n<td>T+60s</td>\n<td>Recovery 1차: 실패 (1/2)</td>\n</tr>\n<tr>\n<td>T+70s</td>\n<td><code class=\"language-text\">docker start dev-redis</code></td>\n</tr>\n<tr>\n<td>T+90s</td>\n<td>Recovery 2차: <code class=\"language-text\">container.start()</code> → 성공. failureCount 초기화</td>\n</tr>\n</tbody>\n</table>\n<p>이 시나리오가 중요한 이유는 <code class=\"language-text\">MAX_RECOVERY_ATTEMPTS</code>의 값과 직결되기 때문이다. 처음에는 1로 설정했다. 1번 실패하면 바로 DOWN. 하지만 Redis 재시작이 30초 이상 걸리는 경우(AOF 로드 등) Recovery 1차 시점에 아직 Redis가 안 올라와서 즉시 DOWN → Docker 재시작이 트리거된다. Recovery가 존재하는 의미가 없어진다.</p>\n<p>3으로 올리는 것도 검토했다. 3회면 약 90초의 복구 대기 시간을 확보할 수 있지만, 진짜 복구 불가능한 상황에서 Docker 재시작까지 최소 3분이 걸린다. 단일 인스턴스에서 3분은 너무 길다.</p>\n<p>2회로 결정했다. 약 60초의 복구 대기 시간을 확보하면서, 진짜 안 되는 경우 2분 이내에 Docker 재시작으로 넘어간다. 시나리오 5가 이 판단을 검증한 것이다.</p>\n<h2>종합</h2>\n<table>\n<thead>\n<tr>\n<th>시나리오</th>\n<th>Recovery</th>\n<th>HealthIndicator</th>\n<th>Docker 재시작</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Redis 3초 중단</td>\n<td>미개입 (Lettuce)</td>\n<td>UP</td>\n<td>없음</td>\n</tr>\n<tr>\n<td>Redis 30초 중단 후 복구</td>\n<td>1차 성공</td>\n<td>UP</td>\n<td>없음</td>\n</tr>\n<tr>\n<td>Redis 2분+ 장기 중단</td>\n<td>2차 연속 실패</td>\n<td>DOWN</td>\n<td>발생</td>\n</tr>\n<tr>\n<td>Graceful Shutdown</td>\n<td>미개입</td>\n<td>OUT_OF_SERVICE</td>\n<td>없음</td>\n</tr>\n<tr>\n<td>Redis 40초 중단 후 복구</td>\n<td>1차 실패, 2차 성공</td>\n<td>UP</td>\n<td>없음</td>\n</tr>\n</tbody>\n</table>\n<p>5개 시나리오 중 Docker 재시작(Level 2)이 발생한 건 1개뿐이다. 각 레벨은 이전 레벨이 해결하지 못한 상황에서만 개입한다.</p>\n<h2>정리</h2>\n<p>시뮬레이션 전에는 가정이었고, 시뮬레이션 후에야 검증이 됐다. <code class=\"language-text\">docker stop</code>이라는 단순한 방법이었지만, Recovery → HealthIndicator → Docker HEALTHCHECK 체인의 동작을 확인하기에 충분했다.</p>\n<p><code class=\"language-text\">docker stop</code>으로 검증하지 못한 영역은 남아있다. 네트워크 파티션 상황에서 Lettuce가 timeout까지 블로킹되는 동안 스레드 풀과 커넥션 풀이 어떻게 되는지, Recovery가 제때 개입할 수 있는지는 <code class=\"language-text\">iptables</code> 기반의 별도 시뮬레이션이 필요하다.</p>","frontmatter":{"title":"설계는 검증되어야 한다: 3단계 자가 치유 아키텍처 장애 시뮬레이션","date":"2026년 02월 21일 03:02","updated":"2026년 02월 21일 21:02","tags":["ZZOL"],"series":"ZZOL 개발록"},"fields":{"slug":"/disability_simulation/","readingTime":{"minutes":9.27}}},"seriesList":{"edges":[{"node":{"id":"dc0a8329-79ba-55f1-a688-c2f7cbe3f8fd","fields":{"slug":"/ideation/"},"frontmatter":{"title":"사이드 프로젝트에서 실제 서비스까지: 커피빵 기획과 그 시작"}}},{"node":{"id":"b8d473fd-79ee-51d9-ae2b-71c19291cb0e","fields":{"slug":"/persona/"},"frontmatter":{"title":"누가 우리 서비스를 쓸까? : 페르소나 정의를 통한 타겟 유저 구체화"}}},{"node":{"id":"17ea11c4-1553-5ec0-9e45-75f970e28462","fields":{"slug":"/how_spring_handles_websocket/"},"frontmatter":{"title":"Spring WebSocket 내부 동작 원리 파헤치기"}}},{"node":{"id":"9661b2d5-0110-5af9-aedb-86141ccf0b8d","fields":{"slug":"/websocket_reconnection_app_switching/"},"frontmatter":{"title":"모바일 백그라운드 전환 시에도 끊김 없는 WebSocket 연결 경험 만들기"}}},{"node":{"id":"d83add12-9f50-5d42-a371-f347258c1a37","fields":{"slug":"/thread_pool_tuning/"},"frontmatter":{"title":"스레드풀, 감으로 잡지 마세요: 부하 테스트로 증명하는 최적의 설정값"}}},{"node":{"id":"dec80c60-9cbd-54f2-8aae-62e15b54c78f","fields":{"slug":"/infra_design/"},"frontmatter":{"title":"단일 서버에서 분산 환경으로: 확장성 있는 아키텍처로의 전환"}}},{"node":{"id":"3fd12d05-6c82-5d61-91c5-732734d90aa2","fields":{"slug":"/how_redis_pubsub_works/"},"frontmatter":{"title":"Redis Pub/Sub을 활용한 다중 서버 간 실시간 메시지 동기화 전략"}}},{"node":{"id":"deb7290a-38ec-5ac8-a608-ff8d0903f9bb","fields":{"slug":"/coffeeshout_to_zzol/"},"frontmatter":{"title":"커피빵에서 ZZOL로, 유저가 알려준 진짜 서비스"}}},{"node":{"id":"cdc783fb-1df1-5d09-a998-412d8decc001","fields":{"slug":"/graceful_shutdown/"},"frontmatter":{"title":"WebSocket 서비스에서 Graceful Shutdown이 필요한 이유와 구현"}}},{"node":{"id":"e261d9ca-4bb4-5c6a-9d1d-054586acbf8c","fields":{"slug":"/query_improvement/"},"frontmatter":{"title":"쿼리 최적화, 36초를 1초로 줄이기까지"}}},{"node":{"id":"d9f071be-73c0-5fae-9976-1c75172a66b8","fields":{"slug":"/message_recovery/"},"frontmatter":{"title":"네트워크 불안정 상황에서도 메시지 유실 없는 견고한 게임 서버 설계"}}},{"node":{"id":"ee902985-b17e-5dda-8226-5be551279e64","fields":{"slug":"/circuit_breaker/"},"frontmatter":{"title":"외부 서비스 장애로부터 살아남기"}}},{"node":{"id":"f1722009-fa42-55ae-acb7-d4b6627dba94","fields":{"slug":"/rate_limiting/"},"frontmatter":{"title":"ZZOL의 효율적인 서버 자기보호 전략"}}},{"node":{"id":"fd8c281f-b3d7-5fd0-89f8-aee56697c2a4","fields":{"slug":"/custom_health_check/"},"frontmatter":{"title":"HealthIndicator에는 무엇을 담아야 하는가: 상태 판별부터 자가 치유까지"}}},{"node":{"id":"25efdf37-c886-5257-bde8-1c8d524d0384","fields":{"slug":"/disability_simulation/"},"frontmatter":{"title":"설계는 검증되어야 한다: 3단계 자가 치유 아키텍처 장애 시뮬레이션"}}}]},"previous":{"fields":{"slug":"/custom_health_check/"},"frontmatter":{"title":"HealthIndicator에는 무엇을 담아야 하는가: 상태 판별부터 자가 치유까지"}},"next":null},"pageContext":{"id":"25efdf37-c886-5257-bde8-1c8d524d0384","series":"ZZOL 개발록","previousPostId":"fd8c281f-b3d7-5fd0-89f8-aee56697c2a4","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}