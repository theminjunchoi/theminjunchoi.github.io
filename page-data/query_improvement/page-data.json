{"componentChunkName":"component---src-templates-post-jsx","path":"/query_improvement/","result":{"data":{"site":{"siteMetadata":{"title":"minjun.blog"}},"markdownRemark":{"id":"18a2d427-8f34-5a11-baf6-b0687d3a302c","excerpt":"우테코 프로젝트 에서 대시보드 API 성능 개선 작업을 했다. 레이싱 게임 TOP 플레이어 조회 API가 너무 느려서 원인을 파악하고 개선하는 과정을 기록해본다. 문제 상황 dev 환경에 데이터를 넣고 API를 호출해보니 응답이 너무 느렸다. 로 쿼리 실행 계획을 확인해봤다. 문제는 두 가지였다.  테이블 풀스캔 (20만 건) 60만 건짜리 임시 테이블 …","html":"<p>우테코 프로젝트 <code class=\"language-text\">ZZOL(구 커피빵)</code>에서 대시보드 API 성능 개선 작업을 했다. 레이싱 게임 TOP 플레이어 조회 API가 너무 느려서 원인을 파악하고 개선하는 과정을 기록해본다.</p>\n<h2>문제 상황</h2>\n<p>dev 환경에 데이터를 넣고 API를 호출해보니 응답이 너무 느렸다. <code class=\"language-text\">EXPLAIN ANALYZE</code>로 쿼리 실행 계획을 확인해봤다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-> Table scan on mg (cost=20588 rows=199800) (actual time=0.238..463 rows=200000 loops=1)\n-> Aggregate using temporary table (actual time=34947..34947 rows=599999 loops=1)</code></pre></div>\n<p>문제는 두 가지였다.</p>\n<ol>\n<li><code class=\"language-text\">mini_game_play</code> 테이블 풀스캔 (20만 건)</li>\n<li>60만 건짜리 임시 테이블 생성 후 정렬</li>\n</ol>\n<p>120만 건 데이터에서 3개 테이블 JOIN하고 있으니 당연히 느릴 수밖에 없었다.</p>\n<h2>최적화 전 쿼리 흐름</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mini_game_result (120만 건)\n    ↓\nJOIN mini_game_play (20만 건 풀스캔)\n    ↓\nJOIN player (60만 건)\n    ↓\nGROUP BY + ORDER BY (임시 테이블 60만 건)\n    ↓\nLIMIT 5</code></pre></div>\n<p><strong>실행 시간: 36,050ms (36초)</strong></p>\n<h2>적용한 최적화</h2>\n<h3>1. 비정규화</h3>\n<p><code class=\"language-text\">mini_game_type</code>을 <code class=\"language-text\">mini_game_result</code> 테이블에 중복 저장했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- Before: JOIN 필요</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">FROM</span> mini_game_result mr\n<span class=\"token keyword\">JOIN</span> mini_game_play mg <span class=\"token keyword\">ON</span> mr<span class=\"token punctuation\">.</span>mini_game_play_id <span class=\"token operator\">=</span> mg<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">WHERE</span> mg<span class=\"token punctuation\">.</span>mini_game_type <span class=\"token operator\">=</span> <span class=\"token string\">'RACING_GAME'</span>\n\n<span class=\"token comment\">-- After: JOIN 제거</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">FROM</span> mini_game_result mr\n<span class=\"token keyword\">WHERE</span> mr<span class=\"token punctuation\">.</span>mini_game_type <span class=\"token operator\">=</span> <span class=\"token string\">'RACING_GAME'</span></code></pre></div>\n<p><strong>왜 비정규화를 선택했는가?</strong></p>\n<p>무조건 비정규화가 답은 아니라고 생각했다. 도메인 특성과 데이터 분포를 분석하고 나서 결정했다.</p>\n<p>첫째, <strong>mini_game_type은 변경되지 않는 값이다.</strong> 한 번 생성된 미니게임의 타입은 절대 바뀌지 않는다. 레이싱 게임이 카드 게임으로 바뀌는 일은 없다. 비정규화의 가장 큰 단점은 데이터 정합성 관리인데, 변경이 없는 값이라면 이 문제가 사라진다.</p>\n<p>둘째, <strong>mini_game_type의 카디널리티가 낮다.</strong> 현재 게임 타입은 <code class=\"language-text\">RACING_GAME</code>, <code class=\"language-text\">CARD_GAME</code> 두 가지뿐이다. 새로운 게임 타입이 추가되더라도 수십 개 수준일 것이다. 이런 경우 중복 저장해도 저장 공간 증가가 미미하다. varchar(20) × 120만 건 = 약 20MB 정도.</p>\n<p>셋째, <strong>조회 빈도가 압도적으로 높다.</strong> 대시보드 API는 관리자가 수시로 호출하는 조회성 API다. 반면 mini_game_result 데이터는 게임이 끝날 때 한 번 INSERT되고 끝이다. 조회 100번에 쓰기 1번 수준이라면, 조회 성능을 위해 쓰기 시 약간의 오버헤드를 감수하는 게 합리적이다.</p>\n<p>넷째, <strong>JOIN 제거 효과가 크다.</strong> 기존 쿼리는 <code class=\"language-text\">mini_game_play</code> 테이블을 풀스캔해서 <code class=\"language-text\">mini_game_type</code>을 가져왔다. 20만 건 풀스캔 후 필터링. 비정규화하면 이 JOIN 자체가 사라지고, <code class=\"language-text\">mini_game_result</code> 테이블 하나에서 바로 필터링할 수 있다.</p>\n<h3>2. 복합 인덱스 추가</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> idx_mini_game_result_type_created \n<span class=\"token keyword\">ON</span> mini_game_result <span class=\"token punctuation\">(</span>mini_game_type<span class=\"token punctuation\">,</span> created_at<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>왜 복합 인덱스인가?</strong></p>\n<p>단일 컬럼 인덱스가 아니라 복합 인덱스를 선택한 이유가 있다.\n대시보드 API의 쿼리 조건을 보면 항상 두 가지 조건이 함께 쓰인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">WHERE</span> mini_game_type <span class=\"token operator\">=</span> <span class=\"token string\">'RACING_GAME'</span>\n  <span class=\"token operator\">AND</span> created_at <span class=\"token operator\">BETWEEN</span> <span class=\"token string\">'2026-01-01'</span> <span class=\"token operator\">AND</span> <span class=\"token string\">'2026-01-31'</span></code></pre></div>\n<p><code class=\"language-text\">mini_game_type</code> 단일 인덱스만 있으면? RACING_GAME 60만 건을 먼저 찾고, 그 안에서 created_at 조건으로 다시 필터링해야 한다.</p>\n<p><code class=\"language-text\">created_at</code> 단일 인덱스만 있으면? 이번 달 데이터 12만 건을 먼저 찾고, 그 안에서 mini_game_type으로 다시 필터링해야 한다.</p>\n<p>복합 인덱스 <code class=\"language-text\">(mini_game_type, created_at)</code>가 있으면? B-Tree에서 RACING_GAME이면서 이번 달인 데이터를 <strong>한 번에</strong> 찾는다. 6만 건만 정확히 읽으면 된다.</p>\n<p><strong>컬럼 순서도 중요하다.</strong> <code class=\"language-text\">mini_game_type</code>을 앞에 둔 이유는 등호(=) 조건이기 때문이다. <code class=\"language-text\">created_at</code>은 범위(BETWEEN) 조건이다. 등호 조건 → 범위 조건 순서로 인덱스를 구성해야 효율적으로 탄다. 반대로 하면 범위 조건에서 인덱스 스캔이 끊긴다.</p>\n<h2>최적화 후 쿼리 흐름</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mini_game_result (인덱스 레인지 스캔 → 6만 건만 조회)\n    ↓\nJOIN player (PK lookup)\n    ↓\nGROUP BY + ORDER BY (임시 테이블 6만 건)\n    ↓\nLIMIT 5</code></pre></div>\n<p><strong>실행 시간: 1,173ms (1.2초)</strong></p>\n<h2>Before vs After</h2>\n<table>\n<thead>\n<tr>\n<th>항목</th>\n<th>Before</th>\n<th>After</th>\n<th>개선율</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>실행 시간</td>\n<td>36,050ms</td>\n<td>1,173ms</td>\n<td><strong>96.7%</strong></td>\n</tr>\n<tr>\n<td>JOIN 수</td>\n<td>3개</td>\n<td>2개</td>\n<td>33% 감소</td>\n</tr>\n<tr>\n<td>스캔 방식</td>\n<td>풀스캔 (120만 건)</td>\n<td>인덱스 레인지 스캔 (6만 건)</td>\n<td>-</td>\n</tr>\n<tr>\n<td>임시 테이블</td>\n<td>60만 건</td>\n<td>6만 건</td>\n<td>90% 감소</td>\n</tr>\n</tbody>\n</table>\n<h2>삽질했던 부분</h2>\n<h3>1. k6 부하 테스트 결과가 이상했다</h3>\n<p>Before/After 모두 5~6ms로 차이가 없었다. 알고 보니 InnoDB 버퍼풀 캐시 히트 때문이었다. 같은 쿼리 반복하면 메모리에서 읽어서 빠르게 응답함.</p>\n<p>→ 진짜 성능은 <code class=\"language-text\">EXPLAIN ANALYZE</code>로 측정한 콜드 쿼리 시간으로 비교해야 했다.</p>\n<h3>2. 인덱스를 만들어도 안 탔다</h3>\n<p>처음에 데이터를 전부 이번 달(1월)에 몰아넣었더니 인덱스를 만들어도 옵티마이저가 풀스캔을 선택했다. \"어차피 다 읽어야 하니까 풀스캔이 낫다\"고 판단한 것.</p>\n<p>→ 데이터 분포를 1년치로 분산시키고 이번 달은 10%만 넣어서 해결했다. <code class=\"language-text\">ANALYZE TABLE</code>로 통계 정보 갱신도 필요했다.</p>\n<h2>핵심 포인트</h2>\n<ul>\n<li><strong>비정규화</strong>: 무조건 답이 아니다. 변경 가능성, 카디널리티, 조회/쓰기 비율을 따져보고 결정해야 한다.</li>\n<li><strong>복합 인덱스</strong>: WHERE 조건에 자주 함께 쓰이는 컬럼 조합으로 생성. 등호 조건 → 범위 조건 순서로.</li>\n<li><strong>EXPLAIN ANALYZE</strong>: 병목 구간이 어디인지 실제 실행 시간으로 확인 가능.</li>\n<li><strong>데이터 분포</strong>: 테스트 데이터도 실제 운영 환경과 유사하게 구성해야 의미 있는 결과가 나온다.</li>\n</ul>","frontmatter":{"title":"쿼리 최적화, 36초를 1초로 줄이기까지","date":"2026년 02월 05일 09:02","updated":"2026년 02월 17일 18:02","tags":["ZZOL"],"series":"ZZOL 개발록"},"fields":{"slug":"/query_improvement/","readingTime":{"minutes":7.345}}},"seriesList":{"edges":[{"node":{"id":"73de1c69-ae7d-5f22-86dc-b52b20e3b407","fields":{"slug":"/ideation/"},"frontmatter":{"title":"사이드 프로젝트에서 실제 서비스까지: 커피빵 기획과 그 시작"}}},{"node":{"id":"9ea2ee9a-0be2-5dc7-997c-93ab924014eb","fields":{"slug":"/persona/"},"frontmatter":{"title":"누가 우리 서비스를 쓸까? : 페르소나 정의를 통한 타겟 유저 구체화"}}},{"node":{"id":"11058e07-9e58-5f4b-a3a1-62d8527031ea","fields":{"slug":"/how_spring_handles_websocket/"},"frontmatter":{"title":"Spring WebSocket 내부 동작 원리 파헤치기"}}},{"node":{"id":"4c6a7cab-3c43-59bf-a541-9ae287bd3a70","fields":{"slug":"/websocket_reconnection_app_switching/"},"frontmatter":{"title":"모바일 백그라운드 전환 시에도 끊김 없는 WebSocket 연결 경험 만들기"}}},{"node":{"id":"ff05890c-ec4a-5029-bd93-4b8cfa5283b4","fields":{"slug":"/thread_pool_tuning/"},"frontmatter":{"title":"스레드풀, 감으로 잡지 마세요: 부하 테스트로 증명하는 최적의 설정값"}}},{"node":{"id":"82f18340-6032-5dac-9b60-50fb8eea635a","fields":{"slug":"/infra_design/"},"frontmatter":{"title":"단일 서버에서 분산 환경으로: 확장성 있는 아키텍처로의 전환"}}},{"node":{"id":"70183ac3-6408-5d91-a2e9-ac740e347ba2","fields":{"slug":"/how_redis_pubsub_works/"},"frontmatter":{"title":"Redis Pub/Sub을 활용한 다중 서버 간 실시간 메시지 동기화 전략"}}},{"node":{"id":"83a93b64-43b3-5668-8afb-b78d831aaf5a","fields":{"slug":"/coffeeshout_to_zzol/"},"frontmatter":{"title":"커피빵에서 ZZOL로, 유저가 알려준 진짜 서비스"}}},{"node":{"id":"7128f864-794b-58de-88f8-282b8ef949b4","fields":{"slug":"/graceful_shutdown/"},"frontmatter":{"title":"WebSocket 서비스에서 Graceful Shutdown이 필요한 이유와 구현"}}},{"node":{"id":"18a2d427-8f34-5a11-baf6-b0687d3a302c","fields":{"slug":"/query_improvement/"},"frontmatter":{"title":"쿼리 최적화, 36초를 1초로 줄이기까지"}}},{"node":{"id":"00644959-42d4-576a-869d-c1fbcfaec633","fields":{"slug":"/message_recovery/"},"frontmatter":{"title":"네트워크 불안정 상황에서도 메시지 유실 없는 견고한 게임 서버 설계"}}},{"node":{"id":"f47bb328-9638-5c53-be0a-416cc9735b4a","fields":{"slug":"/circuit_breaker/"},"frontmatter":{"title":"외부 서비스 장애로부터 살아남기"}}},{"node":{"id":"02e10cb7-26d6-5d3d-939f-c14571d42969","fields":{"slug":"/rate_limiting/"},"frontmatter":{"title":"ZZOL의 효율적인 서버 자기보호 전략"}}},{"node":{"id":"9ee459e1-d77e-53e2-83d1-cb928b7cc908","fields":{"slug":"/custom_health_check/"},"frontmatter":{"title":"HealthIndicator에는 무엇을 담아야 하는가: 상태 판별부터 자가 치유까지"}}},{"node":{"id":"a10e5e75-ed21-5f31-ae69-9b153741f0d8","fields":{"slug":"/disability_simulation/"},"frontmatter":{"title":"\"재시작하면 고쳐져요\"라는 말을 없애기까지: 3단계 서버 자가 치유기"}}},{"node":{"id":"3da5ed5a-c60c-51d8-8bee-b4ea162abb20","fields":{"slug":"/distributed_lock_and_race_condition/"},"frontmatter":{"title":"분산 락의 함정: 락을 걸었는데도 이벤트가 두 번 처리된 이유"}}}]},"previous":{"fields":{"slug":"/retrospect-2025/"},"frontmatter":{"title":"2025년 회고"}},"next":{"fields":{"slug":"/message_recovery/"},"frontmatter":{"title":"네트워크 불안정 상황에서도 메시지 유실 없는 견고한 게임 서버 설계"}}},"pageContext":{"id":"18a2d427-8f34-5a11-baf6-b0687d3a302c","series":"ZZOL 개발록","previousPostId":"5b9c78fd-7012-5dcf-afc1-cd2861b3d680","nextPostId":"00644959-42d4-576a-869d-c1fbcfaec633"}},"staticQueryHashes":[],"slicesMap":{}}