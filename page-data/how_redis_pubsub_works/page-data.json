{"componentChunkName":"component---src-templates-post-jsx","path":"/how_redis_pubsub_works/","result":{"data":{"site":{"siteMetadata":{"title":"minjun.blog"}},"markdownRemark":{"id":"357a176c-b1d7-5fae-817e-f4624994cbf1","excerpt":"coffeeshout_infra_design 지난 글에서 이어집니다! Redis pub/sub Redis Pub/Sub의 동작 원리를 이해하면 왜 이 방식이 실시간 게임 동기화에 적합한지 명확해진다. Redis 내부 구조 Redis 서버는 C로 구현되어 있으며, Pub/Sub 기능은 내부적으로 매우 단순한 자료구조로 동작한다. Redis 서버의  구조체는…","html":"<p><a href=\"/coffeeshout_infra_design\" data-wiki-link=\"true\">coffeeshout_infra_design</a> 지난 글에서 이어집니다!</p>\n<h2>Redis pub/sub</h2>\n<p>Redis Pub/Sub의 동작 원리를 이해하면 왜 이 방식이 실시간 게임 동기화에 적합한지 명확해진다.</p>\n<h3>Redis 내부 구조</h3>\n<p>Redis 서버는 C로 구현되어 있으며, Pub/Sub 기능은 내부적으로 매우 단순한 자료구조로 동작한다. Redis 서버의 <code class=\"language-text\">redisServer</code> 구조체는 다음과 같은 Pub/Sub 관련 정보를 메모리에 유지한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">redisServer</span> <span class=\"token punctuation\">{</span>\n    dict <span class=\"token operator\">*</span>pubsub_channels<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 채널명 → 구독자 리스트 해시테이블</span>\n    list <span class=\"token operator\">*</span>pubsub_patterns<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 패턴 구독자들 링크드리스트</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>클라이언트가 <code class=\"language-text\">SUBSCRIBE room.events</code>를 실행하면, Redis는 <code class=\"language-text\">pubsub_channels</code> 해시테이블에서 해당 채널을 찾고, 구독자 리스트에 클라이언트를 추가한다. 이후 <code class=\"language-text\">PUBLISH room.events {...}</code> 메시지가 들어오면, 해시테이블에서 채널을 O(1)로 조회하고 구독자 리스트를 순회하며 메시지를 전송한다.</p>\n<h3>메시지 전달 흐름</h3>\n<p>커피빵 서비스에서 플레이어가 Ready 상태를 변경하는 과정을 예로 들어보자.</p>\n<h4>1. 클라이언트가 WebSocket으로 메시지 전송</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 브라우저에서 전송</span>\nstompClient<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/app/room/ABC123/update-ready'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">joinCode</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ABC2\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">playerName</span><span class=\"token operator\">:</span> <span class=\"token string\">\"홍길동\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">isReady</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>2. Spring WebSocket Controller가 수신</h4>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@MessageMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/room/{joinCode}/update-ready\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">broadcastReady</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@DestinationVariable</span> <span class=\"token class-name\">String</span> joinCode<span class=\"token punctuation\">,</span> \n                          <span class=\"token class-name\">ReadyChangeMessage</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">PlayerReadyEvent</span> event <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PlayerReadyEvent</span><span class=\"token punctuation\">(</span>\n        joinCode<span class=\"token punctuation\">,</span> \n        message<span class=\"token punctuation\">.</span><span class=\"token function\">playerName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        message<span class=\"token punctuation\">.</span><span class=\"token function\">isReady</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    roomEventPublisher<span class=\"token punctuation\">.</span><span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Spring이 STOMP 프로토콜로 들어온 메시지를 파싱해 컨트롤러로 라우팅한다. 이후 도메인 이벤트인 <code class=\"language-text\">PlayerReadyEvent</code>를 생성하며, 이때 이벤트 ID와 타임스탬프가 자동으로 생성된다.</p>\n<h4>3. RedisTemplate의 convertAndSend()</h4>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RoomBaseEvent</span><span class=\"token punctuation\">></span></span> <span class=\"token keyword\">void</span> <span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">convertAndSend</span><span class=\"token punctuation\">(</span>roomEventTopic<span class=\"token punctuation\">.</span><span class=\"token function\">getTopic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">RedisTemplate</code>은 Spring Data Redis가 제공하는 추상화 레이어다. 내부에서는 다음 과정이 순차적으로 실행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// RedisTemplate 내부 동작</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">convertAndSend</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> channel<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 1. 채널명 직렬화: \"room.events\" → byte[]</span>\n    <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> rawChannel <span class=\"token operator\">=</span> <span class=\"token string\">\"room.events\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UTF_8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 2. 메시지 객체 직렬화: PlayerReadyEvent → JSON → byte[]</span>\n    <span class=\"token class-name\">GenericJackson2JsonRedisSerializer</span> serializer <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> rawMessage <span class=\"token operator\">=</span> serializer<span class=\"token punctuation\">.</span><span class=\"token function\">serialize</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 결과: {\"eventId\":\"uuid-123\",\"joinCode\":\"ABC2\",\"playerName\":\"홍길동\",\"isReady\":true,...}</span>\n    \n    <span class=\"token comment\">// 3. Lettuce Connection으로 전달</span>\n    connection<span class=\"token punctuation\">.</span><span class=\"token function\">publish</span><span class=\"token punctuation\">(</span>rawChannel<span class=\"token punctuation\">,</span> rawMessage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>4. Lettuce의 RESP 프로토콜 변환</h4>\n<p>Lettuce는 Netty 기반의 비동기 Redis 클라이언트다. Redis와 통신하기 위해서는 **RESP(REdis Serialization Protocol)**라는 Redis 전용 프로토콜로 변환해야 한다.</p>\n<p>RESP는 Redis의 표준 통신 규약으로, 텍스트 기반의 간단한 프로토콜이다. 각 데이터 타입을 특정 문자로 시작해 구분한다:</p>\n<ul>\n<li><code class=\"language-text\">*</code> : 배열 (Array)</li>\n<li><code class=\"language-text\">$</code> : 문자열 길이 (Bulk String)</li>\n<li><code class=\"language-text\">:</code> : 정수 (Integer)</li>\n<li><code class=\"language-text\">+</code> : 단순 문자열 (Simple String)</li>\n<li><code class=\"language-text\">-</code> : 에러 (Error)</li>\n</ul>\n<p>예를 들어 <code class=\"language-text\">PUBLISH room.events {\"data\":\"...\"}</code> 명령은 다음과 같이 변환된다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">*3\\r\\n\n$7\\r\\n\nPUBLISH\\r\\n\n$11\\r\\n\nroom.events\\r\\n\n$152\\r\\n\n{\"eventId\":\"uuid-123\",\"joinCode\":\"ABC2\",\"playerName\":\"홍길동\",\"isReady\":true,...}\\r\\n</code></pre></div>\n<p>해석하면:</p>\n<ul>\n<li><code class=\"language-text\">*3</code>: 3개 요소를 가진 배열</li>\n<li><code class=\"language-text\">$7</code>: 7바이트 문자열 → <code class=\"language-text\">PUBLISH</code></li>\n<li><code class=\"language-text\">$11</code>: 11바이트 문자열 → <code class=\"language-text\">room.events</code></li>\n<li><code class=\"language-text\">$152</code>: 152바이트 문자열 → JSON 메시지</li>\n</ul>\n<p>Lettuce 내부 코드로 보면 다음과 같다</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Lettuce 내부</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Long</span> <span class=\"token function\">publish</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> channel<span class=\"token punctuation\">,</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// RESP 프로토콜로 인코딩</span>\n    <span class=\"token class-name\">CommandArgs</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span> args <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CommandArgs</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>codec<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addKey</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span>   <span class=\"token comment\">// room.events</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addValue</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// JSON 메시지</span>\n    \n    <span class=\"token class-name\">Command</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Long</span><span class=\"token operator\">></span> command <span class=\"token operator\">=</span> commandBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">publish</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// Netty를 통해 비동기 전송</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Lettuce는 Netty의 <code class=\"language-text\">ByteBuf</code>에 RESP 형식의 바이트 데이터를 작성한 뒤, 비동기로 전송한다.</p>\n<h4>5. Netty의 비동기 네트워크 통신</h4>\n<p>Netty는 Java NIO를 기반으로 한 비동기 네트워크 프레임워크다. Lettuce가 Netty를 사용하는 이유는 <strong>논블로킹 I/O</strong>와 <strong>커넥션 재사용</strong> 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// Netty 내부 (간략화)</span>\n<span class=\"token class-name\">Channel</span> channel <span class=\"token operator\">=</span> <span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Redis 서버와의 TCP 연결</span>\n\n<span class=\"token comment\">// ByteBuf에 RESP 데이터 작성</span>\n<span class=\"token class-name\">ByteBuf</span> buffer <span class=\"token operator\">=</span> channel<span class=\"token punctuation\">.</span><span class=\"token function\">alloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">buffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nbuffer<span class=\"token punctuation\">.</span><span class=\"token function\">writeBytes</span><span class=\"token punctuation\">(</span>respProtocolBytes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 비동기 전송</span>\n<span class=\"token class-name\">ChannelFuture</span> future <span class=\"token operator\">=</span> channel<span class=\"token punctuation\">.</span><span class=\"token function\">writeAndFlush</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 결과를 기다리지 않고 즉시 리턴 (Non-blocking)</span>\nfuture<span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span>writeCompleteListener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Netty는 내부적으로 <strong>이벤트 루프(Event Loop)</strong> 스레드를 사용해 여러 커넥션의 I/O를 효율적으로 처리한다. 하나의 스레드가 수천 개의 커넥션을 동시에 관리할 수 있어, 커넥션마다 스레드를 생성하는 전통적인 방식보다 훨씬 효율적이다.</p>\n<p>최종적으로 TCP 소켓을 통해 Redis 서버로 데이터가 전송된다.</p>\n<h4>6. Redis 서버의 메시지 처리</h4>\n<p>Redis 서버는 <strong>단일 스레드 이벤트 루프</strong> 구조로 동작한다. 멀티스레딩 없이 어떻게 수천 개의 동시 연결을 처리할 수 있을까? 바로 <strong>I/O 멀티플렉싱(I/O Multiplexing)</strong> 기술 덕분이다.</p>\n<p><strong>I/O 멀티플렉싱이란?</strong></p>\n<p>전통적인 블로킹 I/O 방식에서는 <code class=\"language-text\">read()</code>를 호출하면 데이터가 도착할 때까지 스레드가 대기한다. 1000개의 클라이언트를 처리하려면 1000개의 스레드가 필요하고, 이는 컨텍스트 스위칭 비용으로 성능 저하를 일으킨다.</p>\n<p>I/O 멀티플렉싱은 <strong>하나의 스레드가 여러 소켓을 동시에 감시</strong>할 수 있게 해준다. Linux의 <code class=\"language-text\">epoll</code>, BSD/macOS의 <code class=\"language-text\">kqueue</code> 같은 시스템 콜이 이 기능을 제공한다.</p>\n<p>동작 방식:</p>\n<ol>\n<li>수백~수천 개의 소켓을 <code class=\"language-text\">epoll</code>에 등록</li>\n<li><code class=\"language-text\">epoll_wait()</code> 호출 → 이벤트(데이터 도착, 쓰기 가능 등) 발생 시까지 대기</li>\n<li>이벤트 발생 시 어떤 소켓에서 이벤트가 발생했는지 반환</li>\n<li>해당 소켓에서만 <code class=\"language-text\">read()</code> 또는 <code class=\"language-text\">write()</code> 수행</li>\n<li>다시 <code class=\"language-text\">epoll_wait()</code>로 돌아가 다음 이벤트 대기</li>\n</ol>\n<p>Redis는 이 방식으로 단일 스레드로도 초당 수만 건의 요청을 처리한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Redis 이벤트 루프 (간략화)</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">aeMain</span><span class=\"token punctuation\">(</span>aeEventLoop <span class=\"token operator\">*</span>eventLoop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>eventLoop<span class=\"token operator\">-></span>stop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// epoll_wait() 호출 - 이벤트 발생 시까지 대기</span>\n        numevents <span class=\"token operator\">=</span> <span class=\"token function\">aeApiPoll</span><span class=\"token punctuation\">(</span>eventLoop<span class=\"token punctuation\">,</span> tvp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> numevents<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            aeFileEvent <span class=\"token operator\">*</span>fe <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>eventLoop<span class=\"token operator\">-></span>events<span class=\"token punctuation\">[</span>eventLoop<span class=\"token operator\">-></span>fired<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>fd<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            \n            <span class=\"token comment\">// 읽기 이벤트 (클라이언트가 데이터 전송)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fe<span class=\"token operator\">-></span>mask <span class=\"token operator\">&amp;</span> AE_READABLE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                fe<span class=\"token operator\">-></span><span class=\"token function\">rfileProc</span><span class=\"token punctuation\">(</span>eventLoop<span class=\"token punctuation\">,</span> fd<span class=\"token punctuation\">,</span> fe<span class=\"token operator\">-></span>clientData<span class=\"token punctuation\">,</span> mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            \n            <span class=\"token comment\">// 쓰기 이벤트 (클라이언트에게 전송 가능)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fe<span class=\"token operator\">-></span>mask <span class=\"token operator\">&amp;</span> AE_WRITABLE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                fe<span class=\"token operator\">-></span><span class=\"token function\">wfileProc</span><span class=\"token punctuation\">(</span>eventLoop<span class=\"token punctuation\">,</span> fd<span class=\"token punctuation\">,</span> fe<span class=\"token operator\">-></span>clientData<span class=\"token punctuation\">,</span> mask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>클라이언트가 <code class=\"language-text\">PUBLISH</code> 명령을 보내면:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// 1. 소켓에서 데이터 읽기 (간략화)</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">readQueryFromClient</span><span class=\"token punctuation\">(</span>aeEventLoop <span class=\"token operator\">*</span>el<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>privdata<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> mask<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    client <span class=\"token operator\">*</span>c <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>client<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> privdata<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// TCP 소켓에서 데이터 읽기</span>\n    nread <span class=\"token operator\">=</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> c<span class=\"token operator\">-></span>querybuf <span class=\"token operator\">+</span> qblen<span class=\"token punctuation\">,</span> readlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// RESP 프로토콜 파싱</span>\n    <span class=\"token function\">processInputBuffer</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 2. PUBLISH 명령 실행 (간략화)</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">publishCommand</span><span class=\"token punctuation\">(</span>client <span class=\"token operator\">*</span>c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// c->argv[1] = \"room.events\" (채널명)</span>\n    <span class=\"token comment\">// c->argv[2] = JSON 메시지</span>\n    \n    <span class=\"token keyword\">int</span> receivers <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// pubsub_channels 해시테이블에서 채널 조회 (O(1))</span>\n    dictEntry <span class=\"token operator\">*</span>de <span class=\"token operator\">=</span> <span class=\"token function\">dictFind</span><span class=\"token punctuation\">(</span>server<span class=\"token punctuation\">.</span>pubsub_channels<span class=\"token punctuation\">,</span> c<span class=\"token operator\">-></span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>de<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        list <span class=\"token operator\">*</span>subscribers <span class=\"token operator\">=</span> <span class=\"token function\">dictGetVal</span><span class=\"token punctuation\">(</span>de<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token comment\">// 구독자 리스트 순회 (O(N), N=구독자 수)</span>\n        listNode <span class=\"token operator\">*</span>ln<span class=\"token punctuation\">;</span>\n        listIter li<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">listRewind</span><span class=\"token punctuation\">(</span>subscribers<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>li<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ln <span class=\"token operator\">=</span> <span class=\"token function\">listNext</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>li<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            client <span class=\"token operator\">*</span>subscriber <span class=\"token operator\">=</span> ln<span class=\"token operator\">-></span>value<span class=\"token punctuation\">;</span>\n            \n            <span class=\"token comment\">// 각 구독자의 output buffer에 메시지 추가</span>\n            <span class=\"token function\">addReplyPubsubMessage</span><span class=\"token punctuation\">(</span>subscriber<span class=\"token punctuation\">,</span> c<span class=\"token operator\">-></span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> c<span class=\"token operator\">-></span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            receivers<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token comment\">// 발행자에게 응답: 몇 명에게 전송했는지</span>\n    <span class=\"token function\">addReplyLongLong</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> receivers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 3. output buffer의 데이터를 실제로 전송 (간략화)</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">writeToClient</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> fd<span class=\"token punctuation\">,</span> client <span class=\"token operator\">*</span>c<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> handler_installed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token function\">clientHasPendingReplies</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// write() 시스템콜로 TCP 소켓에 전송</span>\n        nwritten <span class=\"token operator\">=</span> <span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> c<span class=\"token operator\">-></span>buf <span class=\"token operator\">+</span> c<span class=\"token operator\">-></span>sentlen<span class=\"token punctuation\">,</span> c<span class=\"token operator\">-></span>bufpos <span class=\"token operator\">-</span> c<span class=\"token operator\">-></span>sentlen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nwritten <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        \n        c<span class=\"token operator\">-></span>sentlen <span class=\"token operator\">+=</span> nwritten<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 과정에서 Redis는 메시지를 저장하지 않는다. 받자마자 바로 구독자들의 output buffer에 추가하고 전송한다. 이것이 <strong>Fire-and-Forget</strong> 방식이며, 실시간성을 극대화하는 설계다.</p>\n<h4>7. 구독자 측 수신 및 처리</h4>\n<p>각 서버 인스턴스의 Lettuce 클라이언트가 메시지를 수신하면, RESP 프로토콜을 디코딩해 Spring의 <code class=\"language-text\">MessageListener</code>로 전달한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onMessage</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Message</span> message<span class=\"token punctuation\">,</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> pattern<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 1. 메시지 body를 String으로 변환</span>\n    <span class=\"token class-name\">String</span> body <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">getBody</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 2. eventType 추출</span>\n    <span class=\"token class-name\">RoomEventType</span> eventType <span class=\"token operator\">=</span> <span class=\"token function\">extractEventType</span><span class=\"token punctuation\">(</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// PLAYER_READY</span>\n    \n    <span class=\"token comment\">// 3. JSON을 Java 객체로 역직렬화</span>\n    <span class=\"token class-name\">PlayerReadyEvent</span> event <span class=\"token operator\">=</span> objectMapper<span class=\"token punctuation\">.</span><span class=\"token function\">readValue</span><span class=\"token punctuation\">(</span>body<span class=\"token punctuation\">,</span> <span class=\"token class-name\">PlayerReadyEvent</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 4. 핸들러로 위임</span>\n    <span class=\"token class-name\">RoomEventHandler</span> handler <span class=\"token operator\">=</span> handlerFactory<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span>eventType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    handler<span class=\"token punctuation\">.</span><span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>8. 비즈니스 로직 실행</h4>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PlayerReadyEvent</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 로컬 메모리에서 Room 조회 (네트워크 통신 없음)</span>\n    <span class=\"token class-name\">Room</span> room <span class=\"token operator\">=</span> roomQueryService<span class=\"token punctuation\">.</span><span class=\"token function\">getByJoinCode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">JoinCode</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span><span class=\"token function\">joinCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// Player 찾기</span>\n    <span class=\"token class-name\">Player</span> player <span class=\"token operator\">=</span> room<span class=\"token punctuation\">.</span><span class=\"token function\">findPlayer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">PlayerName</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span><span class=\"token function\">playerName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 상태 변경 (로컬 메모리)</span>\n    player<span class=\"token punctuation\">.</span><span class=\"token function\">updateReadyState</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span><span class=\"token function\">isReady</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// 로컬 캐시 업데이트</span>\n    roomCommandService<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span>room<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// WebSocket 브로드캐스팅</span>\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PlayerResponse</span><span class=\"token punctuation\">></span></span> responses <span class=\"token operator\">=</span> room<span class=\"token punctuation\">.</span><span class=\"token function\">getPlayers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PlayerResponse</span><span class=\"token operator\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n    messagingTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">convertAndSend</span><span class=\"token punctuation\">(</span>\n        <span class=\"token string\">\"/topic/room/\"</span> <span class=\"token operator\">+</span> event<span class=\"token punctuation\">.</span><span class=\"token function\">joinCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">WebSocketResponse</span><span class=\"token punctuation\">.</span><span class=\"token function\">success</span><span class=\"token punctuation\">(</span>responses<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 핵심은 <strong>데이터 조회가 로컬 메모리에서 즉시 처리</strong>된다는 점이다. 네트워크 통신도, 직렬화/역직렬화도 필요 없다. Redis는 오직 변경 이벤트를 전파하는 메시지 브로커 역할만 수행한다.</p>\n<h4>9. 최종 클라이언트 수신</h4>\n<p>Spring WebSocket이 STOMP 프로토콜로 메시지를 인코딩해 해당 방을 구독 중인 모든 WebSocket 세션에 전송한다. 각 브라우저는 메시지를 수신해 UI를 업데이트한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">stompClient<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/topic/room/ABC123'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">message</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// {success: true, data: [{playerName: \"홍길동\", isReady: true}, ...]}</span>\n    \n    <span class=\"token function\">updatePlayerList</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>주요 특징과 트레이드오프</h3>\n<h4>Fire-and-Forget 방식</h4>\n<p>Redis Pub/Sub은 메시지를 저장하지 않는다. 구독자가 없거나 네트워크 문제로 수신하지 못하면 메시지는 유실된다. 이는 실시간성을 위한 설계 선택이다. 메시지 저장 없이 즉시 전달만 하기 때문에 레이턴시가 최소화된다.</p>\n<p>커피빵의 경우 대부분의 이벤트가 일시적 상태 변경(Ready 상태, 메뉴 선택 등)이기 때문에 이런 특성이 오히려 적합했다. 메시지 유실을 무조건 막아야하거나 Race Condition이 발생할 수 있는 상황을 대비해서 일정부분은 Redis Stream을 적용했다.</p>\n<h4>네트워크 레이턴시</h4>\n<p>전체 메시지 전파 과정에서 발생하는 네트워크 구간은 다음과 같다:</p>\n<ol>\n<li>발행 서버 → Redis (TCP 왕복)</li>\n<li>Redis → 구독 서버들 (TCP 왕복 × N)</li>\n</ol>\n<p>동일 리전 내에서는 대략 1~5ms 정도의 지연이 발생한다. 이는 사람이 체감하기 어려운 수준이다.</p>\n<h4>언어 경계를 넘는 통신</h4>\n<p>흥미로운 점은 이 전체 과정에서 <strong>여러 언어와 프로토콜의 경계를 넘는다</strong>는 것이다.</p>\n<ul>\n<li>Java 애플리케이션에서 이벤트 발행</li>\n<li>Lettuce(Java)가 RESP 프로토콜로 변환</li>\n<li>네트워크를 타고 Redis(C)로 전달</li>\n<li>Redis가 C 레벨의 해시테이블과 링크드리스트로 처리</li>\n<li>다시 네트워크를 타고 구독자의 Lettuce(Java)로 수신</li>\n<li>Java 객체로 복원돼 비즈니스 로직 실행</li>\n</ul>\n<p>각 언어는 서로 다른 메모리 관리 방식과 자료구조를 사용하지만, RESP 프로토콜이라는 공통 인터페이스를 통해 안정적으로 통신한다. 이런 추상화 덕분에 개발자는 Redis 내부 구현을 몰라도 Pub/Sub을 사용할 수 있다.</p>\n<p>다만 이런 경계를 넘을 때마다 직렬화/역직렬화와 네트워크 비용이 발생한다는 점은 항상 염두에 둬야 한다. 그럼에도 불구하고 이 방식을 선택한 이유는, <strong>읽기 작업은 로컬 메모리에서 즉시 처리되고, 쓰기 작업만 네트워크를 타기 때문</strong>이다. 결과적으로 성능 저하 없이 분산 환경 동기화를 달성할 수 있었다.</p>\n<h2>참고자료</h2>\n<h3>Redis 공식 자료</h3>\n<ul>\n<li><a href=\"https://redis.io/docs/latest/develop/pubsub/\">Redis Pub/Sub</a> - Pub/Sub 공식 가이드</li>\n<li><a href=\"https://redis.io/docs/latest/develop/reference/protocol-spec/\">RESP Protocol Specification</a> - RESP 프로토콜 공식 명세</li>\n<li><a href=\"https://github.com/redis/redis/blob/unstable/src/pubsub.c\">Redis GitHub - pubsub.c</a> - Pub/Sub 구현 소스코드</li>\n</ul>\n<h3>Redis 내부 구조 분석</h3>\n<ul>\n<li><a href=\"https://jameshfisher.com/2017/03/01/redis-pubsub-under-the-hood/\">Redis Pub/Sub under the hood</a> - Redis Pub/Sub 소스코드 상세 분석 (Pusher 엔지니어 작성)</li>\n</ul>","frontmatter":{"title":"How Redis Pub/Sub Works","date":"2025년 10월 14일 09:10","updated":"2025년 10월 15일 09:10","tags":["CoffeeShout"],"series":"커피빵(CoffeeShout) 개발록"},"fields":{"slug":"/how_redis_pubsub_works/","readingTime":{"minutes":14.68}}},"seriesList":{"edges":[{"node":{"id":"78009f4c-9d4d-5ede-8df8-21c4b3e0827a","fields":{"slug":"/coffeeshout_ideation/"},"frontmatter":{"title":"커피빵(CoffeeShout) 기획"}}},{"node":{"id":"4b6f5513-eb5e-5e14-9f1e-49e5551e3e0a","fields":{"slug":"/coffeeshout_persona/"},"frontmatter":{"title":"커피빵(CoffeeShout) 페르소나"}}},{"node":{"id":"dfcf707f-6928-5b1d-b1f6-d48ea4b28c21","fields":{"slug":"/coffeeshout_server_tech_stack/"},"frontmatter":{"title":"커피빵(CoffeeShout) 서버 기술스택"}}},{"node":{"id":"dd19080d-8383-5cdb-9519-2c28e9545ae2","fields":{"slug":"/how_spring_handles_websocket/"},"frontmatter":{"title":"How Spring Handles WebSocket"}}},{"node":{"id":"e97246be-857f-59db-8b03-b350f11fa429","fields":{"slug":"/coffeeshout_websocket_reconnection_app_switching/"},"frontmatter":{"title":"WebSocket Reconnection on App Switching"}}},{"node":{"id":"a1219698-1514-531d-8307-8beb79ee82fb","fields":{"slug":"/coffeeshout_infra_design/"},"frontmatter":{"title":"커피빵(CoffeeShout) 분산환경 구축"}}},{"node":{"id":"357a176c-b1d7-5fae-817e-f4624994cbf1","fields":{"slug":"/how_redis_pubsub_works/"},"frontmatter":{"title":"How Redis Pub/Sub Works"}}}]},"previous":{"fields":{"slug":"/coffeeshout_infra_design/"},"frontmatter":{"title":"커피빵(CoffeeShout) 분산환경 구축"}},"next":null},"pageContext":{"id":"357a176c-b1d7-5fae-817e-f4624994cbf1","series":"커피빵(CoffeeShout) 개발록","previousPostId":"a1219698-1514-531d-8307-8beb79ee82fb","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}