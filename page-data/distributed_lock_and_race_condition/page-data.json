{"componentChunkName":"component---src-templates-post-jsx","path":"/distributed_lock_and_race_condition/","result":{"data":{"site":{"siteMetadata":{"title":"minjun.blog"}},"markdownRemark":{"id":"3da5ed5a-c60c-51d8-8bee-b4ea162abb20","excerpt":"ZZOL에서 Redis Stream을 이벤트 버스로 사용하고 있다. 방 생성, 게임 시작, 룰렛 결과 등 거의 모든 도메인 이벤트가 Redis Stream을 통해 흐른다. 그런데 이벤트가 두 번 이상 도착할 수 있다는 사실을 인지했고, 이를 해결하기 위한 멱등성 처리를 설계한 과정을 기록한다. 문제 인식: 이벤트가 왜 두 번 오는가 처음에는 이벤트 중복을…","html":"<p>ZZOL에서 Redis Stream을 이벤트 버스로 사용하고 있다. 방 생성, 게임 시작, 룰렛 결과 등 거의 모든 도메인 이벤트가 Redis Stream을 통해 흐른다. 그런데 이벤트가 <strong>두 번 이상 도착할 수 있다</strong>는 사실을 인지했고, 이를 해결하기 위한 멱등성 처리를 설계한 과정을 기록한다.</p>\n<h2>문제 인식: 이벤트가 왜 두 번 오는가</h2>\n<p>처음에는 이벤트 중복을 고민하지 않았다. Redis Stream에 이벤트를 발행하면, 리스너가 읽어서 처리하면 끝이라고 생각했다. 하지만 운영 로그를 보다가 이상한 걸 발견했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[INFO] 룰렛 결과 DB 저장 완료: eventId=abc-123, joinCode=A1B2\n[INFO] 룰렛 결과 DB 저장 완료: eventId=abc-123, joinCode=A1B2</code></pre></div>\n<p>같은 <code class=\"language-text\">eventId</code>로 같은 이벤트가 두 번 처리됐다. 당첨자가 DB에 두 행으로 들어갔다.</p>\n<p>원인을 추적해보니 <code class=\"language-text\">StreamMessageListenerContainer</code>의 동작 방식 때문이었다. ZZOL은 Consumer Group 없이 <code class=\"language-text\">StreamOffset.fromStart()</code>로 메시지를 읽는 구조다. 이 방식은 Container가 시작될 때마다 Stream의 처음부터 읽는다. Docker HEALTHCHECK에 의한 컨테이너 재시작, Recovery에 의한 Container 재시작, 배포에 의한 재시작 — 이유가 뭐든 Container가 재시작되면 이미 처리한 이벤트를 다시 읽게 된다.</p>\n<p>Redis Stream 자체가 at-least-once delivery다. \"최소 한 번은 전달하지만 정확히 한 번은 보장하지 않는다.\"</p>\n<p>이게 왜 문제인가. 룰렛 결과 저장 이벤트(<code class=\"language-text\">RouletteSpinEvent</code>)가 두 번 처리되면 같은 당첨자가 DB에 두 번 INSERT된다. 미니게임 결과 저장(<code class=\"language-text\">MiniGameFinishedEvent</code>)이 두 번 처리되면 같은 플레이어의 점수가 두 행으로 들어간다. 대시보드 통계가 틀어지고, 최악의 경우 게임 진행 자체가 꼬인다.</p>\n<h3>fromStart()를 쓰면 재시작할 때마다 전체를 다시 읽는 거 아닌가?</h3>\n<p>이 의문이 당연히 생긴다. Stream에 이벤트가 10,000건 쌓여있으면 재시작할 때마다 10,000건을 다시 읽는 건가?</p>\n<p>그렇게 되지 않도록 <code class=\"language-text\">StreamPublisher</code>에서 발행 시 MAXLEN trimming을 걸어뒀다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">stringRedisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">opsForStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>\n    <span class=\"token class-name\">StreamRecords</span><span class=\"token punctuation\">.</span><span class=\"token function\">newRecord</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">in</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">getRedisKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ofObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">XAddOptions</span><span class=\"token punctuation\">.</span><span class=\"token function\">maxlen</span><span class=\"token punctuation\">(</span>maxLength<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">approximateTrimming</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// maxLength=100</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">MAXLEN ~ 100</code>이면 Stream에 100건 이상 쌓이지 않는다. approximate trimming(<code class=\"language-text\">~</code>)이라 정확히 100건은 아니지만, 대략 100건 근처에서 오래된 메시지가 잘린다. 재시작 시 최대 100건만 읽고, 이미 처리된 건 done key 체크로 스킵하는 구조다.</p>\n<p>100건으로 잡은 이유는, 모든 스트림(<code class=\"language-text\">room</code>, <code class=\"language-text\">room:join</code>, <code class=\"language-text\">cardgame:select</code>, <code class=\"language-text\">minigame</code>, <code class=\"language-text\">racinggame</code>)의 공통 설정이 <code class=\"language-text\">max-length: 100</code>이기 때문이다. 게임 한 판에서 발생하는 이벤트가 보통 20 ~ 30건이고, 동시에 3 ~ 4개 방이 진행되는 피크 시간을 고려하면 100건이면 최근 이벤트를 충분히 담는다.</p>\n<p>다만 이 구조에는 한계가 있다. 멀티 인스턴스로 확장하면 fromStart()는 각 인스턴스가 모든 이벤트를 중복으로 읽게 되므로, 그때는 Consumer Group으로 전환해야 한다. 현재는 단일 인스턴스이고 MAXLEN 100건이라 fromStart()의 실질적 비용이 무시할 수준이라고 판단했다.</p>\n<h2>선택지 분석: 처음에는 DB에서 막으려고 했다</h2>\n<h3>첫 번째 시도: DB Unique Constraint</h3>\n<p>가장 먼저 떠올린 건 DB에서 막는 것이었다. 이벤트 처리 이력을 저장하는 테이블을 하나 만들고, <code class=\"language-text\">event_id</code>에 UNIQUE 제약을 걸어서 중복 INSERT 시 예외를 잡아 무시하는 방식이다.</p>\n<p>실제로 <code class=\"language-text\">MiniGameResultSaveEventListener</code>의 코드를 보면 이게 왜 안 되는지 바로 보인다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MiniGameFinishedEvent</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">RoomEntity</span> roomEntity <span class=\"token operator\">=</span> roomJpaRepository\n        <span class=\"token punctuation\">.</span><span class=\"token function\">findFirstByJoinCodeOrderByCreatedAtDesc</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span><span class=\"token function\">joinCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">orElseThrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">MiniGameEntity</span> miniGameEntity <span class=\"token operator\">=</span> miniGameJpaRepository\n        <span class=\"token punctuation\">.</span><span class=\"token function\">findByRoomSessionAndMiniGameType</span><span class=\"token punctuation\">(</span>roomEntity<span class=\"token punctuation\">,</span> miniGameType<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">orElseThrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ... 방 조회, 미니게임 조회, 결과 계산 ...</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Player</span> player <span class=\"token operator\">:</span> room<span class=\"token punctuation\">.</span><span class=\"token function\">getPlayers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        miniGameResultJpaRepository<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span>resultEntity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 플레이어 수만큼 INSERT</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이벤트 핸들러가 단순 INSERT 하나가 아니다. 방 조회 → 미니게임 조회 → 플레이어별 결과 생성 → 다건 INSERT라는 복잡한 흐름이다. UNIQUE 제약으로 마지막 INSERT에서 터뜨리면, 그 앞의 조회와 연산이 전부 헛수고다. 그리고 <code class=\"language-text\">RoulettePersistenceService.saveRoomStatus()</code>처럼 INSERT가 아니라 UPDATE인 경우에는 UNIQUE 제약이 아예 적용되지 않는다.</p>\n<h3>두 번째 시도: Consumer Group</h3>\n<p>Redis Stream의 정석적인 방법이다. Consumer Group을 만들고, 이벤트를 처리한 후 <code class=\"language-text\">XACK</code>를 보내면 같은 이벤트를 다시 받지 않는다. exactly-once에 가장 가까운 구조다.</p>\n<p>하지만 Consumer Group을 도입하면 관리해야 할 것들이 생긴다. PEL(Pending Entries List) 모니터링, XCLAIM으로 stuck 메시지 회수, Consumer가 비정상 종료됐을 때 재등록 처리. ZZOL은 단일 인스턴스다. Consumer Group은 \"여러 Consumer가 하나의 Stream을 나눠 읽는\" 시나리오에 최적화되어 있고, 단일 인스턴스에서는 이 관리 오버헤드가 실익 대비 과하다고 판단했다.</p>\n<p>그리고 Consumer Group을 쓰더라도 멱등성 처리가 불필요해지는 건 아니다. <code class=\"language-text\">XACK</code> 전에 앱이 죽으면 같은 메시지가 다시 전달된다. Consumer Group은 중복 전달 빈도를 줄여주지만, 완전히 없애지는 못한다. 결국 \"이벤트가 두 번 와도 안전한\" 구조는 별도로 필요하다.</p>\n<h3>최종 선택: 분산 락 + 처리 완료 마킹</h3>\n<p>두 가지 문제를 각각 해결하는 구조를 선택했다.</p>\n<ul>\n<li><strong>분산 락</strong>: 같은 이벤트가 동시에 두 번 실행되는 것을 방지한다.</li>\n<li><strong>처리 완료 마킹(done key)</strong>: 이전에 이미 처리된 이벤트를 스킵한다.</li>\n</ul>\n<p>선택 이유는 세 가지다.</p>\n<p>첫째, 이벤트 핸들러의 로직 변경 없이 적용할 수 있다. AOP로 메서드 진입 전에 중복 체크를 하기 때문에, 비즈니스 로직은 \"이벤트가 정확히 한 번만 들어온다\"고 가정하고 작성하면 된다.</p>\n<p>둘째, INSERT뿐 아니라 UPDATE, 복합 로직에도 동일하게 적용된다. done key 체크가 메서드 레벨에서 일어나기 때문에 내부 로직이 뭐든 상관없다.</p>\n<p>셋째, 이미 Redisson이 분산 락 용도로 프로젝트에 들어있었다. 새로운 의존성 추가 없이 구현 가능했다.</p>\n<h2>설계: 어노테이션 각 값을 왜 그렇게 잡았는가</h2>\n<h3>어노테이션</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">METHOD</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RetentionPolicy</span><span class=\"token punctuation\">.</span><span class=\"token constant\">RUNTIME</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token annotation punctuation\">@interface</span> <span class=\"token class-name\">RedisLock</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">String</span> <span class=\"token function\">key</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                          <span class=\"token comment\">// SpEL 표현식</span>\n    <span class=\"token class-name\">String</span> <span class=\"token function\">lockPrefix</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token string\">\"lock:\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">String</span> <span class=\"token function\">donePrefix</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token string\">\"done:\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> <span class=\"token function\">waitTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>            <span class=\"token comment\">// 락 대기 시간 (ms)</span>\n    <span class=\"token keyword\">long</span> <span class=\"token function\">leaseTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 락 유지 시간 (ms)</span>\n    <span class=\"token keyword\">long</span> <span class=\"token function\">doneTtl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token number\">600000</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// done key TTL (ms)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>key: SpEL을 선택한 이유</h3>\n<p>처음에는 단순히 <code class=\"language-text\">String key()</code>에 고정 문자열을 넣으려고 했다. 그런데 이벤트마다 고유 식별자의 위치가 다르다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 이벤트마다 식별자 접근 방식이 다름</span>\n<span class=\"token class-name\">RouletteSpinEvent</span>           → event<span class=\"token punctuation\">.</span><span class=\"token function\">eventId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">MiniGameFinishedEvent</span>       → event<span class=\"token punctuation\">.</span><span class=\"token function\">eventId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">StartMiniGameCommandEvent</span>   → event<span class=\"token punctuation\">.</span><span class=\"token function\">eventId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>지금은 전부 <code class=\"language-text\">eventId()</code>지만, 나중에 <code class=\"language-text\">joinCode + miniGameType</code> 같은 복합 키가 필요해질 수도 있다. SpEL(Spring Expression Language)을 사용하면 런타임에 메서드 파라미터의 필드를 꺼내서 동적으로 키를 만들 수 있다. <code class=\"language-text\">@Cacheable</code>이나 <code class=\"language-text\">@PreAuthorize</code>에서 <code class=\"language-text\">#result</code>, <code class=\"language-text\">#id</code> 같은 표현식을 쓰는 것과 같은 원리다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RedisLock</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"#event.eventId()\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RouletteSpinEvent</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">#event.eventId()</code>가 SpEL 파서를 통해 <code class=\"language-text\">\"abc-123\"</code> 같은 실제 값으로 치환되고, <code class=\"language-text\">lockPrefix</code>와 합쳐져서 <code class=\"language-text\">event:lock:abc-123</code>이 최종 락 키가 된다.</p>\n<h3>waitTime=0: 즉시 포기하는 게 맞는가?</h3>\n<p>Redisson의 <code class=\"language-text\">tryLock(waitTime, leaseTime, unit)</code>에서 <code class=\"language-text\">waitTime</code>은 \"락이 이미 잡혀있을 때 최대 얼마나 기다릴 것인가\"를 의미한다. 동작을 정리하면 이렇다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tryLock(waitTime=0):\n  Redis에 \"락 비었어?\" 물어봄\n    → 비었으면 → 락 획득 → return true\n    → 잡혀있으면 → 기다리지 않고 즉시 → return false\n\ntryLock(waitTime=100ms):\n  Redis에 \"락 비었어?\" 물어봄\n    → 비었으면 → 락 획득 → return true\n    → 잡혀있으면 → 100ms 동안 대기하며 재시도\n      → 100ms 안에 풀리면 → 락 획득 → return true\n      → 100ms 지나도 안 풀리면 → return false</code></pre></div>\n<p>처음에는 <code class=\"language-text\">waitTime=100</code>을 줬었다. \"혹시 네트워크 지연으로 tryLock이 실패하면 이벤트가 유실되지 않나?\"라는 걱정 때문이었다.</p>\n<p>하지만 Redisson의 <code class=\"language-text\">tryLock</code> 동작을 확인해보니 이 걱정이 불필요했다. <code class=\"language-text\">waitTime</code>은 <strong>Redis에 도달한 후 락이 점유됐을 때의 대기 시간</strong>이지, 네트워크 통신 자체의 타임아웃이 아니다. Redis 네트워크 장애나 연결 실패 시에는 false가 아니라 <code class=\"language-text\">RedisConnectionException</code>이나 <code class=\"language-text\">RedisTimeoutException</code> 같은 <strong>예외가 던져진다.</strong> 즉 tryLock의 false는 \"정상적으로 Redis에 도달했지만 락이 이미 점유된 상태\"를 의미한다.</p>\n<p>그래서 false가 나오면 \"다른 스레드가 같은 이벤트를 처리 중\"이라는 의미이고, 기다릴 필요 없이 바로 포기하는 게 맞다. 어차피 처리가 끝나면 done key가 마킹되고, 나중에 같은 이벤트가 다시 오면 done key에서 걸러진다.</p>\n<p>다만 <code class=\"language-text\">waitTime</code>과 별개로, tryLock 내부에서 Redis에 명령을 보내고 응답을 기다리는 과정에서 Redisson의 <code class=\"language-text\">timeout</code> 설정만큼 블로킹될 수 있다. Redis가 정상이면 이 구간이 1~5ms지만, Redis가 느려지면(Slowlog 발생, 메모리 부족 등) <code class=\"language-text\">timeout</code> 설정값만큼 스레드가 잡혀있게 된다. Redisson의 기본 <code class=\"language-text\">timeout</code>이 3초이므로, 이를 1초로 튜닝하여 빠른 실패(fail-fast)를 유도했다.</p>\n<p>waitTime을 0이 아닌 값으로 두면 어떻게 되는가? 스레드가 락 대기 큐에 걸린다. Redis Stream 리스너 스레드풀이 점유되면서, 다른 이벤트의 처리가 밀린다. 특히 <code class=\"language-text\">room:join</code> 스트림처럼 단일 스레드(core=1, max=1)로 운영하는 경우, 하나의 이벤트가 락 대기로 100ms를 잡아먹으면 그 뒤의 입장 이벤트가 전부 밀린다.</p>\n<h3>leaseTime=5000ms: 왜 5초인가</h3>\n<p>락이 자동 해제되는 시간이다. 이벤트 핸들러가 비정상 종료(OOM, 스레드 인터럽트 등)해서 <code class=\"language-text\">finally</code>의 <code class=\"language-text\">unlock()</code>이 실행되지 않는 경우를 대비한다.</p>\n<p>선택지는 세 가지였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">leaseTime=1000ms  → 핸들러가 1초 안에 끝나야 함. DB 쿼리 지연 시 락이 먼저 풀림 → 중복 처리 위험\nleaseTime=5000ms  → 실제 실행 시간(~100ms)의 50배. 충분한 안전 마진 + 비정상 시 5초 후 회복\nleaseTime=30000ms → 비정상 종료 후 30초간 해당 이벤트 처리 불가. 과도한 대기</code></pre></div>\n<p>5초를 선택했다. 실제 핸들러 실행 시간이 대부분 100ms 이내이므로 안전 마진이 충분하고, 비정상 종료 시에도 5초면 다음 시도가 가능하다.</p>\n<h3>doneTtl=600000ms (10분): 왜 10분인가</h3>\n<p>done key가 Redis에 유지되는 시간이다. 이 시간이 지나면 done key가 사라지고, 같은 이벤트가 다시 처리될 수 있다.</p>\n<p>ZZOL의 게임 생명주기를 기준으로 잡았다. 방 하나가 생성되고 게임이 끝나기까지 길어야 10~15분이다. 게임이 끝난 뒤에 같은 이벤트가 다시 도착하는 건 현실적으로 불가능하다. 10분이면 게임이 진행 중인 동안 중복을 완벽히 막으면서, 게임이 끝난 후에는 Redis 메모리를 자연스럽게 회수한다.</p>\n<p>1시간, 24시간으로 잡으면 더 안전하지만 Redis 메모리를 점유한다. ZZOL은 EC2 t4g.medium에서 Redis를 운영하고 있고, 메모리가 넉넉하지 않다. done key 하나당 수십 바이트지만, 이벤트가 매 게임마다 수십 건씩 발생하면 누적된다.</p>\n<p>done key의 키 구조는 <code class=\"language-text\">{donePrefix}{eventId}</code> 형태의 일반 String이다. <code class=\"language-text\">opsForValue().set(key, \"done\", Duration)</code>으로 개별 TTL을 설정한다. Hash(HSET)도 고려했지만, Redis에서 Hash 필드 단위 TTL 설정이 기본적으로 지원되지 않기 때문에(Redis 7.4 이전) 이벤트별 개별 만료가 불가능했다. String SET이 이 용도에 더 적합했다.</p>\n<h2>AOP 구현: 더블 체크가 필요한 이유</h2>\n<h3>처음 구현 (버그 있음)</h3>\n<p>처음에는 이렇게 구현했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 1단계: done key 확인</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isAlreadyProcessed</span><span class=\"token punctuation\">(</span>doneKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 2단계: 락 획득</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">tryLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 3단계: 비즈니스 로직</span>\n<span class=\"token class-name\">Object</span> result <span class=\"token operator\">=</span> joinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 4단계: done 마킹</span>\n<span class=\"token function\">markAsDone</span><span class=\"token punctuation\">(</span>doneKey<span class=\"token punctuation\">,</span> doneTtl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>\"done key 확인 → 락 획득 → 실행 → done 마킹\" 순서면 충분하다고 생각했다. 하지만 이 코드에는 Race Condition이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Thread A: isAlreadyProcessed → false (통과)\nThread B: isAlreadyProcessed → false (통과)  ← A가 아직 done 마킹 안 함\nThread A: tryLock → 성공 → 비즈니스 로직 실행 → done 마킹 → unlock\nThread B: tryLock → 성공 (A가 이미 풀었으니까!) → 비즈니스 로직 실행 → 중복!</code></pre></div>\n<p><code class=\"language-text\">waitTime=0</code>이라서 B가 바로 튕겨 나갈 것 같지만, 문제는 <strong>시간차</strong>다. A가 락을 풀고 난 직후에 B가 tryLock을 시도하면, 락이 비어있으니 B가 정상적으로 잡는다. B는 첫 번째 done key 체크를 이미 통과한 상태이므로, A가 마킹한 done key를 모른 채 비즈니스 로직을 실행한다.</p>\n<h3>더블 체크로 Race Condition을 막는 흐름</h3>\n<p>아래 다이어그램에서 첫 번째가 싱글 체크(버그), 두 번째가 더블 체크(수정)다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\n[Single Check — Race Condition]\n\n  Thread A                  Redis                    Thread B\n     |                        |                         |\n     |--- GET done:abc ------>|                         |\n     |&lt;-- nil ----------------|                         |\n     |                        |                         |\n     |--- LOCK lock:abc ----->|                         |\n     |&lt;-- OK (acquired) ------|                         |\n     |                        |&lt;----- GET done:abc -----|\n     |  execute handler       |-----> nil ------------->|  ← not yet marked\n     |                        |                         |\n     |--- SET done:abc ------>|                         |\n     |--- UNLOCK lock:abc --->|                         |\n     |                        |&lt;----- LOCK lock:abc ----|\n     |                        |-----> OK (acquired!) -->|  ← lock was released\n     |                        |                         |\n     |                        |     execute handler     |  ← DUPLICATE!\n     |                        |                         |\n\n\n[Double Check — Race Condition Blocked]\n\n  Thread A                  Redis                    Thread B\n     |                        |                         |\n     |--- GET done:abc ------>|                         |\n     |&lt;-- nil ----------------|                         |\n     |                        |                         |\n     |--- LOCK lock:abc ----->|                         |\n     |&lt;-- OK (acquired) ------|                         |\n     |                        |&lt;----- GET done:abc -----|\n     |  execute handler       |-----> nil ------------->|  ← same so far\n     |                        |                         |\n     |--- SET done:abc ------>|                         |\n     |--- UNLOCK lock:abc --->|                         |\n     |                        |&lt;----- LOCK lock:abc ----|\n     |                        |-----> OK (acquired!) -->|\n     |                        |                         |\n     |                        |&lt;----- GET done:abc -----|  ← 2nd check!\n     |                        |-----> \"done\" ---------->|\n     |                        |                         |\n     |                        |       return null       |  ← blocked\n     |                        |&lt;----- UNLOCK lock:abc --|</code></pre></div>\n<p>핵심은 Thread B가 락을 잡은 직후에 done key를 <strong>한 번 더 확인</strong>하는 것이다. Thread A가 이미 done을 마킹해뒀기 때문에, B는 비즈니스 로직에 진입하지 않고 빠진다.</p>\n<h3>수정된 구현 (더블 체크)</h3>\n<p>락을 획득한 직후에 done key를 한 번 더 확인해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Around</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@annotation(coffeeshout.global.lock.RedisLock)\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ProceedingJoinPoint</span> joinPoint<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Throwable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">MethodSignature</span> signature <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodSignature</span><span class=\"token punctuation\">)</span> joinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">getSignature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">Method</span> method <span class=\"token operator\">=</span> signature<span class=\"token punctuation\">.</span><span class=\"token function\">getMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">RedisLock</span> redisLock <span class=\"token operator\">=</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">getAnnotation</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RedisLock</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> lockKey <span class=\"token operator\">=</span> <span class=\"token function\">getLockKey</span><span class=\"token punctuation\">(</span>joinPoint<span class=\"token punctuation\">,</span> redisLock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> doneKey <span class=\"token operator\">=</span> <span class=\"token function\">getDoneKey</span><span class=\"token punctuation\">(</span>joinPoint<span class=\"token punctuation\">,</span> redisLock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 1단계: 락 획득 전 빠른 체크 (성능 최적화)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isAlreadyProcessed</span><span class=\"token punctuation\">(</span>doneKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        log<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"이미 처리된 이벤트 (스킵): doneKey={}\"</span><span class=\"token punctuation\">,</span> doneKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">final</span> <span class=\"token class-name\">RLock</span> lock <span class=\"token operator\">=</span> redissonClient<span class=\"token punctuation\">.</span><span class=\"token function\">getLock</span><span class=\"token punctuation\">(</span>lockKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> acquired <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">tryLock</span><span class=\"token punctuation\">(</span>\n                redisLock<span class=\"token punctuation\">.</span><span class=\"token function\">waitTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                redisLock<span class=\"token punctuation\">.</span><span class=\"token function\">leaseTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span><span class=\"token constant\">MILLISECONDS</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>acquired<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            log<span class=\"token punctuation\">.</span><span class=\"token function\">warn</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"락 획득 실패 (스킵): lockKey={}\"</span><span class=\"token punctuation\">,</span> lockKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 2단계: 락 획득 후 이중 체크 (Race Condition 방지)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isAlreadyProcessed</span><span class=\"token punctuation\">(</span>doneKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            log<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"락 획득 후 이중 체크 - 이미 처리됨 (스킵): doneKey={}\"</span><span class=\"token punctuation\">,</span> doneKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 3단계: 비즈니스 로직 실행</span>\n        <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span> result <span class=\"token operator\">=</span> joinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 4단계: 처리 완료 마킹</span>\n        <span class=\"token function\">markAsDone</span><span class=\"token punctuation\">(</span>doneKey<span class=\"token punctuation\">,</span> redisLock<span class=\"token punctuation\">.</span><span class=\"token function\">doneTtl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"락 획득 중 인터럽트 발생\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">isHeldByCurrentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>1단계의 done key 체크는 <strong>성능 최적화</strong>다. 이미 처리된 이벤트는 락을 잡을 필요도 없이 <code class=\"language-text\">EXISTS</code> 하나로 스킵한다. 재시작 후 Stream을 처음부터 읽을 때, 이미 처리된 수십 건의 이벤트가 전부 락 획득을 시도하면 Redisson에 불필요한 부하가 걸린다.</p>\n<p>2단계의 done key 체크가 <strong>정합성 보장</strong>이다. 락을 잡은 상태에서 다시 확인하므로, 1단계를 통과한 뒤 다른 스레드가 먼저 처리한 경우를 잡아낸다. Java의 Double-checked locking 패턴과 동일한 구조다.</p>\n<p><code class=\"language-text\">lock.isHeldByCurrentThread()</code> 체크가 있는 이유는, leaseTime이 만료되어 락이 자동 해제된 상태에서 <code class=\"language-text\">unlock()</code>을 호출하면 <code class=\"language-text\">IllegalMonitorStateException</code>이 발생하기 때문이다.</p>\n<h2>@Order(HIGHEST_PRECEDENCE): 트랜잭션보다 먼저 실행해야 하는 이유</h2>\n<p>이벤트 핸들러에 <code class=\"language-text\">@Transactional</code>이 함께 붙어있는 경우가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@EventListener</span>\n<span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@RedisLock</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"#event.eventId()\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MiniGameFinishedEvent</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>처음에는 <code class=\"language-text\">@Order</code>를 신경 쓰지 않았다. 동작은 했으니까. 하지만 중복 이벤트가 들어올 때 DB 커넥션 풀 모니터링에서 이상한 게 보였다. 중복 이벤트가 들어올 때마다 active connection이 순간적으로 올라갔다.</p>\n<p>원인은 AOP 실행 순서였다. <code class=\"language-text\">@Transactional</code>이 <code class=\"language-text\">@RedisLock</code>보다 먼저 실행되면 이런 일이 벌어진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@Transactional이 바깥인 경우:\n\n  Transaction begin        ← DB 커넥션 획득\n      |\n      v\n  RedisLock (done key 체크)\n      |\n      +-- 이미 처리됨 → return null\n                          ← 아무 쿼리도 안 날렸지만 커넥션은 이미 잡혀있었음</code></pre></div>\n<p>done key 체크로 스킵하더라도 이미 DB 커넥션을 잡은 상태다. 중복 이벤트가 올 때마다 쓸모없는 커넥션이 소비된다. 재시작 후 Stream의 100건을 다시 읽을 때, 이미 처리된 90건이 전부 DB 커넥션을 잡았다가 놓는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Order</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Ordered</span><span class=\"token punctuation\">.</span><span class=\"token constant\">HIGHEST_PRECEDENCE</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 트랜잭션(@Order 기본값 LOWEST)보다 먼저 실행</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RedisLockAspect</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">HIGHEST_PRECEDENCE</code>로 두면 RedisLock이 가장 먼저 실행된다. 중복 이벤트는 트랜잭션이 열리기 전에 걸러지므로 DB 커넥션 낭비가 없다.</p>\n<h2>적용</h2>\n<p>실제로 <code class=\"language-text\">@RedisLock</code>을 적용한 곳은 세 군데다.</p>\n<p><strong>1. 미니게임 결과 저장</strong> — 가장 먼저 문제가 발견된 곳</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@EventListener</span>\n<span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@RedisLock</span><span class=\"token punctuation\">(</span>\n    key <span class=\"token operator\">=</span> <span class=\"token string\">\"#event.eventId()\"</span><span class=\"token punctuation\">,</span>\n    lockPrefix <span class=\"token operator\">=</span> <span class=\"token string\">\"minigame:result:lock:\"</span><span class=\"token punctuation\">,</span>\n    donePrefix <span class=\"token operator\">=</span> <span class=\"token string\">\"minigame:result:done:\"</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MiniGameFinishedEvent</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 방 조회 → 미니게임 조회 → 플레이어별 결과 INSERT</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>미니게임이 끝나면 모든 플레이어의 점수와 순위를 DB에 저장한다. 플레이어가 4명이면 4건의 INSERT가 발생한다. 이 이벤트가 중복 처리되면 같은 플레이어의 결과가 두 행씩 들어간다. prefix를 <code class=\"language-text\">minigame:result:</code>로 구분한 건, 다른 도메인의 done key와 키가 충돌하지 않도록 네임스페이스를 분리하기 위해서다.</p>\n<p><strong>2. 룰렛 상태 저장 + 결과 저장</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RedisLock</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"#event.eventId()\"</span><span class=\"token punctuation\">,</span> lockPrefix <span class=\"token operator\">=</span> <span class=\"token string\">\"event:lock:\"</span><span class=\"token punctuation\">,</span> donePrefix <span class=\"token operator\">=</span> <span class=\"token string\">\"event:done:\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">saveRoomStatus</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RouletteShowEvent</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    rouletteService<span class=\"token punctuation\">.</span><span class=\"token function\">updateRoomStatusToRoulette</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span><span class=\"token function\">joinCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@RedisLock</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"#event.eventId()\"</span><span class=\"token punctuation\">,</span> lockPrefix <span class=\"token operator\">=</span> <span class=\"token string\">\"event:lock:\"</span><span class=\"token punctuation\">,</span> donePrefix <span class=\"token operator\">=</span> <span class=\"token string\">\"event:done:\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">saveRouletteResult</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RouletteSpinEvent</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    rouletteService<span class=\"token punctuation\">.</span><span class=\"token function\">saveRouletteResult</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span><span class=\"token function\">joinCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">.</span><span class=\"token function\">winner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>룰렛 관련 이벤트는 두 개다. <code class=\"language-text\">RouletteShowEvent</code>는 방 상태를 <code class=\"language-text\">ROULETTE</code>로 UPDATE하고, <code class=\"language-text\">RouletteSpinEvent</code>는 당첨자를 INSERT한다. 특히 <code class=\"language-text\">saveRouletteResult</code>가 두 번 실행되면 같은 당첨자가 두 번 저장되는데, 이게 맨 처음 로그에서 발견한 문제였다.</p>\n<p><strong>3. 미니게임 시작 시 엔티티 생성</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RedisLock</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"#event.eventId()\"</span><span class=\"token punctuation\">,</span> lockPrefix <span class=\"token operator\">=</span> <span class=\"token string\">\"event:lock:\"</span><span class=\"token punctuation\">,</span> donePrefix <span class=\"token operator\">=</span> <span class=\"token string\">\"event:done:\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">saveGameEntities</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StartMiniGameCommandEvent</span> event<span class=\"token punctuation\">,</span> <span class=\"token class-name\">MiniGameType</span> miniGameType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 방 상태 UPDATE → 미니게임 엔티티 INSERT → (첫 게임이면) 플레이어 엔티티 INSERT</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>게임 시작 시 방 상태를 <code class=\"language-text\">PLAYING</code>으로 변경하고, 미니게임과 플레이어 엔티티를 생성한다. 첫 게임 시작인 경우에만 플레이어 엔티티를 INSERT하는 조건 분기(<code class=\"language-text\">room.isFirstStarted()</code>)가 있는데, 이벤트가 두 번 처리되면 두 번 다 <code class=\"language-text\">true</code>를 반환해서 플레이어가 중복 생성된다.</p>\n<h2>eventId 생성: UUID vs Stream Entry ID</h2>\n<p><code class=\"language-text\">@RedisLock</code>의 키로 사용되는 <code class=\"language-text\">eventId</code>는 이벤트 생성 시점에 UUID로 만든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">record</span> <span class=\"token class-name\">RouletteSpinEvent</span><span class=\"token punctuation\">(</span>\n    <span class=\"token class-name\">String</span> eventId<span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">Instant</span> timestamp<span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">String</span> joinCode<span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">BaseEvent</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">RouletteSpinEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> joinCode<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> hostName<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Winner</span> winner<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>\n            <span class=\"token constant\">UUID</span><span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// Publisher가 생성</span>\n            <span class=\"token class-name\">Instant</span><span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            joinCode<span class=\"token punctuation\">,</span>\n            <span class=\"token comment\">// ...</span>\n        <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>UUID 대신 Redis Stream의 Entry ID(<code class=\"language-text\">1234567890-0</code> 형태)를 사용하는 방안도 고려했다. Entry ID는 Redis가 자동 생성하므로 고유성이 보장된다. 하지만 Entry ID는 <code class=\"language-text\">XADD</code>의 <strong>반환값</strong>이다. 이벤트 객체를 생성하는 시점에는 아직 <code class=\"language-text\">XADD</code>를 호출하기 전이므로, 이벤트 record 안에 Entry ID를 담을 수 없다. <code class=\"language-text\">XADD</code> 후에 반환된 Entry ID를 다시 이벤트에 넣으려면 이벤트가 불변 객체(record)인 구조를 깨야 한다. <code class=\"language-text\">eventId</code>를 Publisher가 이벤트 생성 시점에 만들어야 \"같은 이벤트를 식별한다\"는 의미론이 명확하다.</p>\n<p>이벤트가 Redis Stream에 발행될 때 <code class=\"language-text\">eventId</code>가 JSON에 포함되고, Consumer가 읽을 때 역직렬화되면서 같은 <code class=\"language-text\">eventId</code>가 복원된다. 같은 메시지를 두 번 읽어도 <code class=\"language-text\">eventId</code>는 동일하므로, done key 체크에서 두 번째를 걸러낸다.</p>\n<h2>정리</h2>\n<p>Redis Stream의 at-least-once delivery 특성에서 중복 처리를 방지하기 위해, 분산 락과 done key를 조합한 AOP 기반 멱등성 보장 구조를 설계했다.</p>\n<p>핵심 판단을 정리하면 이렇다.</p>\n<p>첫째, 더블 체크가 필수다. 락 획득 전의 done key 체크는 성능 최적화이고, 락 획득 후의 done key 체크가 정합성 보장이다. 둘 중 하나만 있으면 Race Condition이 발생하거나 불필요한 락 획득 비용이 생긴다.</p>\n<p>둘째, <code class=\"language-text\">waitTime=0</code>으로 락 대기를 하지 않는다. Redisson의 tryLock은 네트워크 에러 시 false가 아니라 예외를 던진다. false는 \"다른 스레드가 처리 중\"이라는 의미이므로 기다릴 필요 없이 바로 포기한다. 다만 tryLock 내부의 Redis 명령 자체가 Redisson timeout 설정만큼 블로킹될 수 있으므로, timeout을 1초로 튜닝하여 fail-fast를 유도했다.</p>\n<p>셋째, <code class=\"language-text\">@Order(HIGHEST_PRECEDENCE)</code>로 <code class=\"language-text\">@Transactional</code>보다 먼저 실행한다. 중복 이벤트를 DB 커넥션을 잡기 전에 걸러내서, 커넥션 낭비를 방지한다.</p>\n<p>넷째, fromStart()의 한계를 MAXLEN으로 보완한다. Stream에 100건 이상 쌓이지 않도록 trimming하고, 재시작 시 최대 100건만 읽는다. 멀티 인스턴스 전환 시에는 Consumer Group으로의 마이그레이션이 필요하다.</p>","frontmatter":{"title":"분산 락의 함정: 락을 걸었는데도 이벤트가 두 번 처리된 이유","date":"2026년 03월 01일 11:03","updated":"2026년 03월 02일 00:03","tags":["ZZOL"],"series":"ZZOL 개발록"},"fields":{"slug":"/distributed_lock_and_race_condition/","readingTime":{"minutes":28.09}}},"seriesList":{"edges":[{"node":{"id":"73de1c69-ae7d-5f22-86dc-b52b20e3b407","fields":{"slug":"/ideation/"},"frontmatter":{"title":"사이드 프로젝트에서 실제 서비스까지: 커피빵 기획과 그 시작"}}},{"node":{"id":"9ea2ee9a-0be2-5dc7-997c-93ab924014eb","fields":{"slug":"/persona/"},"frontmatter":{"title":"누가 우리 서비스를 쓸까? : 페르소나 정의를 통한 타겟 유저 구체화"}}},{"node":{"id":"11058e07-9e58-5f4b-a3a1-62d8527031ea","fields":{"slug":"/how_spring_handles_websocket/"},"frontmatter":{"title":"Spring WebSocket 내부 동작 원리 파헤치기"}}},{"node":{"id":"4c6a7cab-3c43-59bf-a541-9ae287bd3a70","fields":{"slug":"/websocket_reconnection_app_switching/"},"frontmatter":{"title":"모바일 백그라운드 전환 시에도 끊김 없는 WebSocket 연결 경험 만들기"}}},{"node":{"id":"ff05890c-ec4a-5029-bd93-4b8cfa5283b4","fields":{"slug":"/thread_pool_tuning/"},"frontmatter":{"title":"스레드풀, 감으로 잡지 마세요: 부하 테스트로 증명하는 최적의 설정값"}}},{"node":{"id":"82f18340-6032-5dac-9b60-50fb8eea635a","fields":{"slug":"/infra_design/"},"frontmatter":{"title":"단일 서버에서 분산 환경으로: 확장성 있는 아키텍처로의 전환"}}},{"node":{"id":"70183ac3-6408-5d91-a2e9-ac740e347ba2","fields":{"slug":"/how_redis_pubsub_works/"},"frontmatter":{"title":"Redis Pub/Sub을 활용한 다중 서버 간 실시간 메시지 동기화 전략"}}},{"node":{"id":"83a93b64-43b3-5668-8afb-b78d831aaf5a","fields":{"slug":"/coffeeshout_to_zzol/"},"frontmatter":{"title":"커피빵에서 ZZOL로, 유저가 알려준 진짜 서비스"}}},{"node":{"id":"7128f864-794b-58de-88f8-282b8ef949b4","fields":{"slug":"/graceful_shutdown/"},"frontmatter":{"title":"WebSocket 서비스에서 Graceful Shutdown이 필요한 이유와 구현"}}},{"node":{"id":"18a2d427-8f34-5a11-baf6-b0687d3a302c","fields":{"slug":"/query_improvement/"},"frontmatter":{"title":"쿼리 최적화, 36초를 1초로 줄이기까지"}}},{"node":{"id":"00644959-42d4-576a-869d-c1fbcfaec633","fields":{"slug":"/message_recovery/"},"frontmatter":{"title":"네트워크 불안정 상황에서도 메시지 유실 없는 견고한 게임 서버 설계"}}},{"node":{"id":"f47bb328-9638-5c53-be0a-416cc9735b4a","fields":{"slug":"/circuit_breaker/"},"frontmatter":{"title":"외부 서비스 장애로부터 살아남기"}}},{"node":{"id":"02e10cb7-26d6-5d3d-939f-c14571d42969","fields":{"slug":"/rate_limiting/"},"frontmatter":{"title":"ZZOL의 효율적인 서버 자기보호 전략"}}},{"node":{"id":"9ee459e1-d77e-53e2-83d1-cb928b7cc908","fields":{"slug":"/custom_health_check/"},"frontmatter":{"title":"HealthIndicator에는 무엇을 담아야 하는가: 상태 판별부터 자가 치유까지"}}},{"node":{"id":"a10e5e75-ed21-5f31-ae69-9b153741f0d8","fields":{"slug":"/disability_simulation/"},"frontmatter":{"title":"\"재시작하면 고쳐져요\"라는 말을 없애기까지: 3단계 서버 자가 치유기"}}},{"node":{"id":"3da5ed5a-c60c-51d8-8bee-b4ea162abb20","fields":{"slug":"/distributed_lock_and_race_condition/"},"frontmatter":{"title":"분산 락의 함정: 락을 걸었는데도 이벤트가 두 번 처리된 이유"}}}]},"previous":{"fields":{"slug":"/disability_simulation/"},"frontmatter":{"title":"\"재시작하면 고쳐져요\"라는 말을 없애기까지: 3단계 서버 자가 치유기"}},"next":null},"pageContext":{"id":"3da5ed5a-c60c-51d8-8bee-b4ea162abb20","series":"ZZOL 개발록","previousPostId":"a10e5e75-ed21-5f31-ae69-9b153741f0d8","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}